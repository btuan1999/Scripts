_G.Reborn_Loaded = true
local ba = 88.5
if AdvancedCallback then
  AdvancedCallback:bind("OnLoseVision", function(bb)
  end)
  AdvancedCallback:bind("OnGainVision", function(bb)
  end)
  AdvancedCallback:bind("OnDash", function(bb)
  end)
  AdvancedCallback:bind("OnUpdateBuff", function(bb, cb)
  end)
end
function OnApplyBuff(bb, cb, db)
  if Data then
    Data:_OnGainBuff(cb, db)
  end
end
function OnRemoveBuff(bb, cb)
  if Data then
    Data:_OnLoseBuff(bb, cb)
  end
end
class("_Streaming")
function _Streaming:__init()
  self.Save = GetSave("SidasAutoCarry")
  AddTickCallback(function()
    self:_OnTick()
  end)
  AddMsgCallback(function(bb, cb)
    self:_OnWndMsg(bb, cb)
  end)
  self:CreateMenu()
  if self.Save.StreamingMode then
    self:EnableStreaming()
  else
    self:DisableStreaming()
  end
end
function _Streaming:_OnTick()
  if self.StreamEnabled then
    self:EnableStreaming()
  end
end
function _Streaming:IsStreaming()
  return self.StreamEnabled
end
function _Streaming:_OnWndMsg(bb, cb)
  if bb == KEY_DOWN and cb == 118 then
    if not self.StreamEnabled then
      self:EnableStreaming()
    else
      self:DisableStreaming()
    end
  end
end
function _Streaming:EnableStreaming()
  self.Save.StreamingMode = true
  self.StreamEnabled = true
  _G.RebornStreamingEnabled = true
  if self.StreamingMenu.ClearChat then
    if not self.ChatTimeout then
      self.ChatTimeout = os.clock() + 3
    elseif os.clock() < self.ChatTimeout then
      self:DisableOverlay()
      for i = 0, 15 do
        PrintChat("")
      end
    else
      function _G.PrintChat()
      end
    end
  end
end
function _Streaming:DisableStreaming()
  self.Save.StreamingMode = false
  self.StreamEnabled = false
  _G.RebornStreamingEnabled = false
  if self.ChatTimeout then
    EnableOverlay()
    self.ChatTimeout = nil
  end
end
function _Streaming:CreateMenu()
  self.StreamingMenu = scriptConfig("Sida's Auto Carry: Streaming", "sidasacstreaming")
  self.StreamingMenu:addParam("ClearChat", "Clear Chat When Enabled", SCRIPT_PARAM_ONOFF, true)
  self.StreamingMenu:addParam("Show", "Show Click Marker (Broken)", SCRIPT_PARAM_LIST, 2, {
    "Stream Mode",
    "Always",
    "Never"
  })
  self.StreamingMenu:addParam("Colour", "Click Marker Colour", SCRIPT_PARAM_LIST, 1, {
    "Green",
    "Red",
    "Smart"
  })
  self.StreamingMenu:addParam("MinRand", "Minimum Time Between Clicks", SCRIPT_PARAM_SLICE, 150, 0, 1000, 0)
  self.StreamingMenu:addParam("MaxRand", "Maximum Time Between Clicks", SCRIPT_PARAM_SLICE, 650, 0, 1000, 0)
  self.StreamingMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
  self.StreamingMenu:addParam("sep", "Toggle Streaming Mode with F7", SCRIPT_PARAM_INFO, "")
  self.MenuCreated = true
end
function _Streaming:OnMove()
  if self.MenuCreated then
    local bb = self.StreamingMenu.Colour == 1 and ShowGreenClick or self.StreamingMenu.Colour == 2 and ShowRedClick or function()
      self:Smart()
    end
    if (self.StreamingMenu.Show == 2 or self.StreamingMenu.Show == 1 and self.ChatTimeout) and (not self.NextClick or os.clock() * 1000 > self.NextClick and (not ConfigurationMenu.HoldZone or not (GetDistance(mousePos) < 70))) then
      bb(mousePos)
      self.NextClick = os.clock() * 1000 + math.random(self.StreamingMenu.MinRand, self.StreamingMenu.MaxRand)
    end
  end
end
function _Streaming:Smart()
  if (Keys.MixedMode or Keys.AutoCarry) and Crosshair:GetTarget() then
    ShowRedClick(mousePos)
    self.Red = false
  elseif (Keys.LastHit or Keys.LaneClear or Keys.MixedMode) and ValidTarget(Minions.KillableMinion) then
    ShowRedClick(mousePos)
    self.Red = false
  elseif self.Red then
    ShowRedClick(mousePos)
    self.Red = false
  else
    ShowGreenClick(mousePos)
  end
end
function _Streaming:DisableOverlay()
  _G.DrawText, _G.PrintFloatText, _G.DrawLine, _G.DrawArrow, _G.DrawCircle, _G.DrawRectangle, _G.DrawLines, _G.DrawLines2 = function()
  end, function()
  end, function()
  end, function()
  end, function()
  end, function()
  end, function()
  end, function()
  end
end
Streaming = _Streaming()
function PrintSystemMessage(bb)
  PrintChat(tostring("<font color='#D859CD'>Sida's Auto Carry: Reborn - </font><font color='#adec00'> " .. bb .. "</font>"))
end
PrintSystemMessage("Please wait...")


    local cb = {}
    local db
    cb.Data = {}
    _G.AutoCarry = cb.Data
    class("_NewUpdate")
    NewUpdate = nil
    function _NewUpdate:__init()
      self.Version = ba
      self.Backup = _ENV._G.PrintChat
      self.PrintBackup = _ENV._G.print
      self.Rand = "?rand=" .. _ENV.math.random(1, 10000)
      _ENV.NewUpdate = self
      self:DownloadFiles()
    end
    function _NewUpdate:PrintUpdateMessage(_c)
      _G.PrintChat = self.Backup
      PrintSystemMessage(_c)
      function _G.PrintChat()
        return
      end
    end
    function _NewUpdate:DownloadFiles()
      if not DisableSacUpdate then
        if not FileExist(LIB_PATH .. "Collision.lua") then
          if not self.ColStarted then
            self:PrintUpdateMessage("Downloading Collision Library...")
            DelayAction(function()
              DownloadFile("https://bitbucket.org/SidaBoL/reborn/raw/master/Common/Collision.lua" .. self.Rand, LIB_PATH .. "Collision.lua", function()
                self:DownloadFiles()
              end)
            end, 2)
            HadDownload = true
            self.ColStarted = true
          end
          return
        end
        if not FileExist(LIB_PATH .. "VPrediction.lua") then
          if not self.PredStarted then
            self:PrintUpdateMessage("Downloading VPrediction Library...")
            DelayAction(function()
              DownloadFile("https://bitbucket.org/SidaBoL/reborn/raw/master/Common/VPrediction.lua" .. self.Rand, LIB_PATH .. "VPrediction.lua", function()
                self:DownloadFiles()
              end)
            end, 2)
            self.PredStarted = true
            HadDownload = true
          end
          return
        end
        if not FileExist(LIB_PATH .. "CustomPermaShow.lua") then
          if not self.PermStarted then
            self:PrintUpdateMessage("Downloading CustomPermaShow Library...")
            DelayAction(function()
              DownloadFile("https://bitbucket.org/SidaBoL/reborn/raw/master/Common/CustomPermaShow.lua" .. self.Rand, LIB_PATH .. "CustomPermaShow.lua", function()
                self:DownloadFiles()
              end)
            end, 2)
            self.PermStarted = true
            HadDownload = true
          end
          return
        end
        if not DirectoryExist(SPRITE_PATH .. "SidasAutoCarry") then
          CreateDirectory(SPRITE_PATH .. "SidasAutoCarry")
        end
        if not FileExist(SPRITE_PATH .. "SidasAutoCarry\\Minion_White.png") then
          if not self.WhiteStarted then
            self:PrintUpdateMessage("Downloading Sprite Minion_White.png...")
            DelayAction(function()
              DownloadFile("https://bytebucket.org/SidaBoL/reborn/raw/master/Sprites/SidasAutoCarry/Minion_White.png" .. self.Rand, SPRITE_PATH .. "SidasAutoCarry/Minion_White.png", function()
                self:DownloadFiles()
              end)
            end, 2)
            self.WhiteStarted = true
            HadDownload = true
          end
          return
        end
        if not FileExist(SPRITE_PATH .. "SidasAutoCarry\\Minion_Orange.png") then
          if not self.OrangeStarted then
            self:PrintUpdateMessage("Downloading Sprite Minion_Orange.png...")
            DelayAction(function()
              DownloadFile("https://bytebucket.org/SidaBoL/reborn/raw/master/Sprites/SidasAutoCarry/Minion_Orange.png" .. self.Rand, SPRITE_PATH .. "SidasAutoCarry/Minion_Orange.png", function()
                self:DownloadFiles()
              end)
            end, 2)
            self.OrangeStarted = true
            HadDownload = true
          end
          return
        end
        _G.PrintChat = self.Backup
        if not self.UpdateCheckComplete then
          if not self.UpdateCheckstarted then
            local a_a = GetWebResult("bitbucket.org", "/SidaBoL/reborn/raw/master/Common/reborn.versioncheck")
            if a_a then
              do
                local b_a = string.match(a_a, "version=%d+.%d+")
                b_a = string.match(b_a and b_a or "", "%d+.%d+")
                b_a = tonumber(b_a)
                if b_a and b_a > self.Version and not string.find(string.lower(_G.RebornScriptName), "source") then
                  function _G.PrintChat()
                  end
                  function _G.print()
                  end
                  self.FoundUpdate = true
                  self:PrintUpdateMessage("Downloading update, don't press F9...")
                  DelayAction(function()
                    DownloadFile("https://bitbucket.org/SidaBoL/reborn/raw/master/Sida%27s%20Auto%20Carry%20-%20Reborn.lua" .. self.Rand, SCRIPT_PATH .. _G.RebornScriptName, function()
                      self:PrintUpdateMessage("Updated from r" .. Version .. " to r" .. b_a .. ", double F9 to use new version!")
                      UpdateCheckComplete = true
                      self:DownloadFiles()
                    end)
                  end, 3)
                else
                  self.UpdateCheckComplete = true
                  self:DownloadFiles()
                end
              end
            else
            end
            self.UpdateCheckstarted = true
          end
          return
        end
      end
      if self.FoundUpdate then
        DelayAction(function()
          _G.PrintChat = self.Backup
          _G.print = self.PrintBackup
        end, 5)
      else
        _G.PrintChat = self.Backup
        _G.print = self.PrintBackup
      end
	  end
      function _ReplaceAutoUpdate(a_a)
        if FileExist(LIB_PATH .. a_a .. ".lua") then
          AutoUpdateOverWriteFile = io.open(LIB_PATH .. a_a .. ".lua", "r")
          AutoUpdateOverWriteString = AutoUpdateOverWriteFile:read("*a")
          AutoUpdateOverWriteFile:close()
          AutoUpdateOverWriteString = string.gsub(AutoUpdateOverWriteString, "local AUTOUPDATE = true", "local AUTOUPDATE = false")
          AutoUpdateOverWriteString = string.gsub(AutoUpdateOverWriteString, "local autoUpdate   = true", "local autoUpdate   = false")
          AutoUpdateOverWriteFile = io.open(LIB_PATH .. a_a .. ".lua", "w+")
          AutoUpdateOverWriteFile:write(AutoUpdateOverWriteString)
          AutoUpdateOverWriteFile:close()
        end
      end
      _ReplaceAutoUpdate("VPrediction")
      if not VPrediction then
        require("VPrediction")
      end
      if not Collision then
        require("Collision")
      end
      if not CustomPermaShow then
        require("CustomPermaShow")
      end
      db = VPrediction()
      MODE_AUTOCARRY = 0
      MODE_MIXEDMODE = 1
      MODE_LASTHIT = 2
      MODE_LANECLEAR = 3
      AutoCarry.MODE_AUTOCARRY = 0
      AutoCarry.MODE_MIXEDMODE = 1
      AutoCarry.MODE_LASTHIT = 2
      AutoCarry.MODE_LANECLEAR = 3
      class("_Orbwalker")
      Orbwalker = nil
      STAGE_SHOOT = 0
      STAGE_MOVE = 1
      STAGE_SHOOTING = 2
      AutoCarry.STAGE_SHOOT = 0
      AutoCarry.STAGE_MOVE = 1
      AutoCarry.STAGE_SHOOTING = 2
      RegisteredOnAttacked = {}
      function _Orbwalker:__init()
        self.LastAttack = 0
        self.LastWindUp = 0
        self.LastAttackCooldown = 0
        self.AttackCompletesAt = 0
        self.AfterAttackTime = 0
        self.AttackBufferMax = 400
        self.BaseWindUp = 0.5
        self.BaseAttackSpeed = 0.5
        self.OrbwalkLocationOverride = nil
        self.LastAttackedPosition = {
          x = myHero.x,
          z = myHero.z
        }
        self.EnemyLastHitting = nil
        THRESH_ATTACK_COMPLETED = true
        self.LowestAttackSpeed = myHero.attackSpeed
        AddTickCallback(function()
          self:_OnTick()
        end)
        AddProcessSpellCallback(function(a_a, b_a)
          self:_OnProcessSpell(a_a, b_a)
        end)
        AddAnimationCallback(function(a_a, b_a)
          self:_OnAnimation(a_a, b_a)
        end)
        AddDeleteObjCallback(function(a_a)
          self:_OnDeleteObj(a_a)
        end)
        AddRecvPacketCallback(function(a_a)
          self:_OnReceivePacket(a_a)
        end)
      end
      function _Orbwalker:_OnTick()
        if not self:CanShoot() and self:CanMove() and not self.DoneOnAttacked then
          self.AfterAttackTime = self.LastAttack + self.LastWindUp + self.AttackBufferMax
          self:_OnAttacked()
        end
        if Orbwalker:CanMove() then
          self.AttackInProgress = false
        end
      end
      function _Orbwalker:_OnProcessSpell(a_a, b_a)
        if a_a.isMe then
          if Data:IsAttack(b_a) then
            self.LastAttack = Helper:GetTime() - GetLatency() / 2
            self.LastWindUp = b_a.windUpTime * 1000
            self.LastAttackCooldown = b_a.animationTime * 1000
            self.AttackCompletesAt = self.LastAttack + self.LastWindUp
            self.LastAttackedPosition = {
              x = myHero.x,
              z = myHero.z
            }
            self.DoneOnAttacked = false
            MyHero.DonePreAttack = false
            THRESH_ATTACK_COMPLETED = false
            self.AttackInProgress = true
            self.EnemyLastHitting = nil
            if Minions.KillableMinion and b_a.target == Minions.KillableMinion then
              self.GuaranteedDeadMinion = b_a.target
            end
            if self.BaseAttackSpeed == 0.5 or self.OrbwalkValueReset then
              self.BaseWindUp = 1 / (b_a.windUpTime * myHero.attackSpeed)
              self.BaseAttackSpeed = 1 / (b_a.animationTime * myHero.attackSpeed)
              self.OrbwalkValueReset = false
            end
          elseif Data:IsResetSpell(b_a) then
            self:ResetAttackTimer()
          end
        elseif 1000 > GetDistance(a_a) and a_a.type == myHero.type and ValidTarget(a_a) and Data:IsAttack(b_a) and (b_a.target == myHero or b_a.target.type == "obj_AI_Minion") then
          self.EnemyLastHitting = {
            unit = a_a,
            spell = b_a,
            EndsAt = Helper:GetTime() + b_a.windUpTime * 1000 + b_a.animationTime * 1000 / 2
          }
        end
      end
      function _Orbwalker:_OnReceivePacket(a_a)
      end
      function _Orbwalker:_OnAnimation(a_a, b_a)
        if not self:IsShooting() or not a_a.isMe or b_a == "Run" or b_a == "Idle" then
        end
      end
      function _Orbwalker:_OnDeleteObj(a_a)
        if not a_a or a_a ~= self.LastEnemyAttacked or self:IsShooting() then
        end
      end
      function _Orbwalker:Orbwalk(a_a)
        if MyHero.CanOrbwalk and not self.AttackInProgress then
          if a_a then
            Streaming.Red = true
          end
          if self:CanOrbwalkTarget(a_a) then
            if self:CanShoot() then
              MyHero:Attack(a_a)
            elseif self:CanMove() then
              MyHero:Move()
            end
          else
            MyHero:Move()
          end
        end
      end
      local _c = {}
      for x = 0, 255 do
        if table.contains({
          3,
          4,
          6,
          7
        }, x % 8) and table.contains({
          0,
          1,
          6,
          7
        }, (x % 64 - x % 8) / 8) then
          _c[x] = true
        end
      end
      local ac = {}
      local bc = {
        "Aatrox",
        "Kayle",
        "Rengar"
      }
      local cc = {
        "Nidalee",
        "Elise",
        "Jayce"
      }
      local dc = {"Velkoz", "Thresh"}
      function _Orbwalker:ProcessPacket(a_a)
        if myHero.charName == "Thresh" and a_a.header == 101 then
          a_a.pos = 1
          local b_a = a_a:DecodeF()
          local c_a = a_a:Decode1()
          a_a.pos = 10
          local d_a = a_a:DecodeF()
          if d_a == myHero.networkID and b_a == Orbwalker.LastAttackedNetID and _c[c_a] then
            THRESH_ATTACK_COMPLETED = true
          end
        end
      end
      function _Orbwalker:ResetOrbwalkValues()
        self.OrbwalkValueReset = true
      end
      function _Orbwalker:GetAnimationTime()
        if self then
          return 1 / (myHero.attackSpeed * self.BaseAttackSpeed)
        end
        return 0.5
      end
      function _Orbwalker:GetWindUp()
        if self then
          return 1 / (myHero.attackSpeed * self.BaseWindUp) + MenuManager:GetWindUpOffset() / 1000
        end
        return 0.5
      end
      function _Orbwalker:ResetAttackTimer()
        if self.BaseAttackSpeed ~= 0.5 then
          self.LastAttack = Helper:GetTime() - GetLatency() / 2 - self.LastAttackCooldown
          THRESH_ATTACK_COMPLETED = true
          self.AttackInProgress = false
        end
      end
      function _Orbwalker:OrbwalkToPosition(a_a, b_a)
        if self:CanOrbwalkTarget(a_a) then
          if self:CanShoot() then
            MyHero:Attack(a_a)
          elseif self:CanMove() then
            MyHero:Move(b_a)
          end
        else
          MyHero:Move(b_a)
        end
      end
      function _Orbwalker:OrbwalkIgnoreChecks(a_a)
        if a_a and self:CanShoot() then
          MyHero:Attack(a_a, true)
        elseif not self:CanShoot() then
          MyHero:Move()
        end
      end
      if myHero.charName == "Thresh" then
        function _Orbwalker:CanMove(a_a)
          return THRESH_ATTACK_COMPLETED
        end
      else
        function _Orbwalker:CanMove(a_a)
          a_a = a_a or 0
          return Helper:GetTime() + a_a - 20 + GetLatency() / 2 - self.LastAttack + -MenuManager:GetWindUpOffset() >= 1000 / (myHero.attackSpeed * self.BaseWindUp)
        end
      end
      function _Orbwalker:CanShoot(a_a)
        a_a = a_a or 0
        return Helper:GetTime() + a_a + GetLatency() / 2 - self.LastAttack >= 1000 / (myHero.attackSpeed * self.BaseAttackSpeed)
      end
      function _Orbwalker:GetHitboxRadius(a_a)
        if a_a ~= nil then
          return Helper:GetDistance(a_a.minBBox, a_a.maxBBox) / 2
        end
      end
      function _Orbwalker:CanOrbwalkTarget(a_a)
        if ValidTarget(a_a) then
          if a_a.type == myHero.type then
            if Helper:GetDistance(a_a) - Data:GetGameplayCollisionRadius(a_a.charName) - self:GetScalingRange(a_a) + 10 < MyHero.TrueRange then
              return true
            end
          elseif (a_a.type ~= "obj_AI_Turret" or ConfigurationMenu.AttackStructures) and Helper:GetDistance(a_a) - Data:GetGameplayCollisionRadius(a_a.charName) + 20 < MyHero.TrueRange then
            return true
          end
        end
        return false
      end
      function _Orbwalker:CanOrbwalkTargetCustomRange(a_a, b_a)
        if ValidTarget(a_a) then
          if a_a.type == myHero.type then
            if Helper:GetDistance(a_a) - Data:GetGameplayCollisionRadius(a_a.charName) - self:GetScalingRange(a_a) + 10 < b_a + MyHero.GameplayCollisionRadius + MyHero:GetScalingRange() then
              return true
            end
          elseif Helper:GetDistance(a_a) - Data:GetGameplayCollisionRadius(a_a.charName) + 20 < b_a + MyHero.GameplayCollisionRadius + MyHero:GetScalingRange() then
            return true
          end
        end
        return false
      end
      function _Orbwalker:CanOrbwalkTargetFromPosition(a_a, b_a)
        if ValidTarget(a_a) then
          if a_a.type == myHero.type then
            if Helper:GetDistance(a_a, b_a) - Data:GetGameplayCollisionRadius(a_a.charName) - self:GetScalingRange(a_a) < MyHero.TrueRange then
              return true
            end
          elseif Helper:GetDistance(a_a, b_a) - Data:GetGameplayCollisionRadius(a_a.charName) < MyHero.TrueRange then
            return true
          end
        end
        return false
      end
      function _Orbwalker:IsAfterAttack()
        return Helper:GetTime() + GetLatency() / 2 < self.AfterAttackTime
      end
      function _Orbwalker:GetScalingRange(a_a)
        if a_a.type == myHero.type and a_a.team ~= myHero.team then
          local b_a = Data:GetOriginalHitBox(a_a)
          return b_a and (Helper:GetDistance(a_a.minBBox, a_a.maxBBox) - Data:GetOriginalHitBox(a_a)) / 2 or 0
        end
        return 0
      end
      function _Orbwalker:GetNextAttackTime()
        return self.LastAttack + 1000 / (myHero.attackSpeed * self.BaseAttackSpeed)
      end
      function _Orbwalker:IsShooting()
        return self.AttackInProgress
      end
      function _Orbwalker:AttackOnCooldown()
        return Helper:GetTime() < self:GetNextAttackTime()
      end
      function _Orbwalker:AttackReady()
        return self:CanShoot()
      end
      function RegisterOnAttacked(a_a)
        table.insert(RegisteredOnAttacked, a_a)
      end
      function _Orbwalker:_OnAttacked()
        for a_a, b_a in pairs(RegisteredOnAttacked) do
          b_a()
        end
        self.DoneOnAttacked = true
      end
      function _Orbwalker:OverrideOrbwalkLocation(a_a)
        self.OrbwalkLocationOverride = a_a
      end
      class("_MyHero")
      MyHero = nil
      function _MyHero:__init()
        self.Range = myHero.range
        self.HitBox = Helper:GetDistance(myHero.minBBox)
        self.GameplayCollisionRadius = Data:GetGameplayCollisionRadius(myHero.charName)
        self.TrueRange = self.Range + self.GameplayCollisionRadius
        self.IsMelee = myHero.range < 300
        self.MoveDistance = 480
        self.LastHitDamageBuffer = -15
        self.StartAttackSpeed = 0.665
        self.ChampionAdditionalLastHitDamage = 0
        self.ItemAdditionalLastHitDamage = 0
        self.MasteryAdditionalLastHitDamage = 0
        self.Team = myHero.team == 100 and "Blue" or "Red"
        self.ProjectileSpeed = myHero.range > 300 and db:GetProjectileSpeed(myHero) or math.huge
        self.LastMoved = 0
        self.MoveDelay = 50
        self.CanMove = true
        self.CanAttack = true
        self.CanOrbwalk = true
        self.InStandZone = false
        self.HasStopped = false
        self.IsAttacking = false
        self.SpoilsStacks = 0
        self.IsChannelling = false
        self.LastAttackCommand = Helper:GetTime()
        MyHero = self
        AddTickCallback(function()
          self:_OnTick()
        end)
        AddSendPacketCallback(function(a_a)
          self:_OnSendPacket(a_a)
        end)
        Data:bind("OnLoseBuff", function(a_a, b_a)
          self:_OnLoseBuff(a_a, b_a)
        end)
      end
      function _MyHero:_OnTick()
        self.TrueRange = myHero.range + self.GameplayCollisionRadius + self:GetScalingRange()
        if myHero.range ~= self.Range and myHero.range and myHero.range > 0 and myHero.range < 1500 then
          self.Range = myHero.range
          self.IsMelee = myHero.range < 300
        end
        self:CheckStopMovement()
      end
      function _MyHero:_OnSendPacket(a_a)
      end
      function _MyHero:_OnLoseBuff(a_a, b_a)
        if self.IsChannelling and a_a.isMe then
          for c_a, d_a in pairs(Data.ChannelledSpells) do
            if d_a.Buff == b_a.name then
              self.IsChannelling = false
            end
          end
        end
      end
      function _MyHero:GetScalingRange()
        local a_a = Data:GetOriginalHitBox(myHero)
        return a_a and (Helper:GetDistance(myHero.minBBox, myHero.maxBBox) - Data:GetOriginalHitBox(myHero)) / 2 or 0
      end
      function _MyHero:SetProjectileSpeed(a_a)
        self.ProjectileSpeed = a_a
      end
      function _MyHero:GetTimeToHitTarget(a_a)
        if self.IsMelee then
          return Helper:GetTime() + Orbwalker.GetWindUp() + GetLatency() / 2
        else
          return GetLatency() / 2 + GetDistance(a_a.pos, myHero.pos) / MyHero.ProjectileSpeed + 1000 / (myHero.attackSpeed * Orbwalker.BaseWindUp)
        end
      end
      function _MyHero:GetTotalAttackDamageAgainstTarget(a_a, b_a)
        local c_a = myHero.totalDamage
        if b_a then
          c_a = self:GetMasteryAdditionalLastHitDamage(c_a, a_a)
        end
        return c_a
      end
      function _MyHero:GetMasteryAdditionalLastHitDamage(a_a, b_a)
        if not ConfigMenu then
          return a_a
        end
        local c_a = 0
        local d_a = 0
        local _aa = 0
        local aaa = 0
        local baa = 0
        local caa = _Damage
        local daa = 0
        local _ba = caa
        if ConfigMenu.ArcaneBlade then
          baa = myHero.ap * 0.05
        end
        if ConfigMenu.DevastatingStrike then
          d_a = 0.06
        end
        if ConfigMenu.DoubleEdgedSword then
          caa = myHero.range < 400 and caa * 1.02 or caa * 1.015
          baa = myHero.range < 400 and baa * 1.02 or baa * 1.015
        end
        if ConfigMenu.Butcher then
          caa = caa + 2
        end
        return (caa * (100 / (100 + target.armor * (1 - d_a))) + baa * (100 / (100 + target.magicArmor * (1 - aaa)))) * (1 - daa)
      end
      function _MyHero:Move(a_a)
        Streaming:OnMove()
        if self:HeroCanMove() and not Helper:IsEvading() and not Orbwalker:IsShooting() and Orbwalker:CanMove() and (not Orbwalker:CanShoot(60) or Orbwalker:CanShoot()) and not self.IsChannelling then
          if ConfigurationMenu.HoldZone and GetDistance(mousePos) < 70 then
            if (Helper:GetTime() + GetLatency() / 2 - Orbwalker.LastAttack) * 0.6 >= 1000 / (myHero.attackSpeed * Orbwalker.BaseWindUp) + AdvancedMenu.MouseOverFix then
              myHero:HoldPosition()
            end
            return
          end
          local b_a = a_a and a_a or mousePos
          b_a = Orbwalker.OrbwalkLocationOverride or b_a
          local c_a = self.MoveDistance + Helper.Latency / 10
          if self.IsMelee and Crosshair.Attack_Crosshair.target and Crosshair.Attack_Crosshair.target.type == myHero.type and MeleeMenu.MeleeStickyRange > 0 and Helper:GetDistance(Crosshair.Attack_Crosshair.target) - Data:GetGameplayCollisionRadius(Crosshair.Attack_Crosshair.target) < MeleeMenu.MeleeStickyRange and Orbwalker:CanOrbwalkTarget(Crosshair.Attack_Crosshair.target) then
            return
          elseif c_a > Helper:GetDistance(b_a) and Helper:GetDistance(b_a) > 100 then
            c_a = Helper:GetDistance(b_a)
          end
          local d_a = math.sqrt((b_a.x - myHero.x) ^ 2 + (b_a.z - myHero.z) ^ 2)
          local _aa = myHero.x + c_a * ((b_a.x - myHero.x) / d_a)
          local aaa = myHero.z + c_a * ((b_a.z - myHero.z) / d_a)
          myHero:MoveTo(_aa, aaa)
          self.LastMoved = Helper.Tick
          self.HasStopped = false
        end
      end
      function _MyHero:Attack(a_a, b_a)
        Streaming.Red = true
        if not self:HeroCanAttack() then
          MyHero:Move()
          return
        end
        if self.CanAttack and not Helper:IsEvading() and Orbwalker:CanShoot() and not self.IsChannelling and not Orbwalker:IsShooting() then
          if a_a.type ~= myHero.type then
            MuramanaOff()
          end
          if not self.DonePreAttack then
            for c_a, d_a in pairs(Plugins.RegisteredPreAttack) do
              d_a(a_a)
            end
            self.DonePreAttack = true
          end
          if Helper:GetTime() > self.LastAttackCommand + 300 then
            myHero:Attack(a_a)
            self.LastAttackCommand = Helper:GetTime()
          end
          Orbwalker.LastEnemyAttacked = a_a
          Orbwalker.LastAttackedNetID = a_a.networkID
        end
      end
      function _MyHero:MovementEnabled(a_a)
        self.CanMove = a_a
      end
      function _MyHero:AttacksEnabled(a_a)
        self.CanAttack = a_a
      end
      function _MyHero:OrbwalkingEnabled(a_a)
        self.CanOrbwalk = a_a
      end
      function _MyHero:HeroCanAttack()
        if not AutoCarryMenu.Attacks and Keys.AutoCarry then
          return false
        elseif not LastHitMenu.Attacks and Keys.LastHit then
          return false
        elseif not MixedModeMenu.Attacks and Keys.MixedMode then
          return false
        elseif not LaneClearMenu.Attacks and Keys.LaneClear then
          return false
        end
        return true
      end
      function _MyHero:HeroCanMove()
        if self.InStandZone or not self.CanMove then
          return false
        elseif not AutoCarryMenu.Movement and Keys.AutoCarry then
          return false
        elseif not LastHitMenu.Movement and Keys.LastHit then
          return false
        elseif not MixedModeMenu.Movement and Keys.MixedMode then
          return false
        elseif not LaneClearMenu.Movement and Keys.LaneClear then
          return false
        end
        return true
      end
      function _MyHero:CheckStopMovement()
        if not MyHero:HeroCanMove() and not self.HasStopped and not Orbwalker.AttackInProgress then
          myHero:HoldPosition()
          self.HasStopped = true
        end
      end
      class("_Crosshair")
      Crosshair = nil
      function _Crosshair:__init(a_a, b_a, c_a, d_a, _aa)
        self.DamageType = a_a and a_a or DAMAGE_PHYSICAL
        self.AttackRange = b_a
        self.SkillRange = c_a
        self.TargetFocused = d_a
        self.TargetLock = nil
        self.IsCaster = _aa
        self.Target = nil
        self.TargetMinion = nil
        self.Attack_Crosshair = TargetSelector(TARGET_LOW_HP_PRIORITY, 2000, DAMAGE_PHYSICAL, self.TargetFocused)
        self.Skills_Crosshair = TargetSelector(TARGET_LOW_HP_PRIORITY, c_a, self.DamageType, self.TargetFocused)
        self.Attack_Crosshair:SetConditional(function(aaa)
          return self:Conditional(aaa)
        end)
        self.Attack_Crosshair:SetDamages(0, myHero.totalDamage, 0)
        self:ArrangePriorities()
        self.RangeScaling = true
        Crosshair = self
        self:UpdateCrosshairRange()
        self:LoadTargetSelector()
        AddTickCallback(function()
          self:_OnTick()
        end)
        AddUnloadCallback(function()
          self:_OnUnload()
        end)
        AddExitCallback(function()
          self:_OnExit()
        end)
      end
      function _Crosshair:_OnTick()
        self.Attack_Crosshair:update()
        local a_a = GetTarget()
        if ConfigurationMenu.FocusedTarget == 3 and a_a and a_a.type == myHero.type and not a_a.dead and a_a.team ~= myHero.team then
          self:SetTargetLock(a_a)
        elseif ModesMenu.TargetLock and (not self.TargetLock or self.TargetLock.dead) then
          self:SetTargetLock(self:GetTarget())
        end
        local b_a = not ModesMenu.TargetLock or self.TargetLock and self.TargetLock.dead
        local c_a = ConfigurationMenu.FocusedTarget ~= 3 or not a_a or a_a.dead or a_a ~= self.TargetLock
        if b_a and c_a then
          self.TargetLock = nil
        end
        if ConfigurationMenu.FocusedTarget == 2 and a_a and Orbwalker:CanOrbwalkTarget(a_a) then
          self.Attack_Crosshair.target = a_a
        end
        if self.Attack_Crosshair.target then
          self.Target = self.Attack_Crosshair.target
        else
          self.Skills_Crosshair:update()
          self.Target = self.Skills_Crosshair.target
        end
        self.TargetMinion = Minions.Target
      end
      function _Crosshair:_OnUnload()
        self:SaveTargetSelector()
      end
      function _Crosshair:_OnExit()
        self:SaveTargetSelector()
      end
      function _Crosshair:ForceTarget(a_a)
        self.UserForcedTarget = a_a
      end
      function _Crosshair:UnlockTarget()
        self.UserForcedTarget = nil
      end
      function _Crosshair:GetTarget()
        if self.TargetLock then
          return self.TargetLock
        elseif ValidTarget(self.Attack_Crosshair.target) then
          return self.Attack_Crosshair.target
        elseif ValidTarget(self.Skills_Crosshair.target) then
          return self.Skills_Crosshair.target
        end
      end
      function _Crosshair:HasOrbwalkTarget()
        return self and self.Target and self.Attack_Crosshair.target and self.Target == self.Attack_Crosshair.target
      end
      function _Crosshair:ArrangePriorities()
        if #GetEnemyHeroes() < 5 then
          return
        end
        for a_a, b_a in pairs(Data.ChampionData) do
          TS_SetHeroPriority(b_a.Priority, b_a.Name)
        end
      end
      function _Crosshair:SetSkillCrosshairRange(a_a)
        self.RangeScaling = false
        self.Skills_Crosshair.range = a_a
      end
      function _Crosshair:UpdateCrosshairRange()
        for a_a, b_a in pairs(Skills.SkillsList) do
          if b_a:GetRange() > self.Skills_Crosshair.range then
            self.Skills_Crosshair.range = b_a:GetRange()
          end
        end
      end
      function _Crosshair:SaveTargetSelector()
        local a_a = GetSave("SidasAutoCarry")
        a_a.TargetSelectorMode = Crosshair.Attack_Crosshair.mode
        a_a:Save()
      end
      function _Crosshair:LoadTargetSelector()
        local a_a = GetSave("SidasAutoCarry")
        if a_a.TargetSelectorMode then
          Crosshair.Attack_Crosshair.mode = a_a.TargetSelectorMode
          Crosshair.Skills_Crosshair.mode = a_a.TargetSelectorMode
        end
      end
      function _Crosshair:Conditional(a_a)
        return a_a.team ~= myHero.team and Orbwalker:CanOrbwalkTarget(a_a) and not Data:EnemyIsImmune(a_a) and (not self.UserForcedTarget or self.UserForcedTarget == a_a)
      end
      function _Crosshair:SetTargetLock(a_a)
        self.TargetLock = a_a
      end
      PRED_LAST_HIT = 0
      PRED_TWO_HITS = 1
      PRED_SKILL = 2
      PRED_UNKILLABLE = 3
      class("_DamagePred")
      DamagePred = nil
      function _DamagePred:__init()
        self.Preds = {}
        DamagePred = self
      end
      function _DamagePred:Reset()
        self.Preds = {}
      end
      function _DamagePred:GetPred(a_a, b_a, c_a)
        local d_a = a_a.health
        local _aa = a_a.health
        if b_a == PRED_LAST_HIT then
          local aaa = Orbwalker:GetWindUp() + GetDistance(a_a.pos, myHero.pos) / MyHero.ProjectileSpeed - 0.07
          count = db:GetPredictedHealth(a_a, aaa, MenuManager:GetFarmOffset())
          _aa, _ = db:GetPredictedHealth(a_a, aaa, MenuManager:GetFarmOffset())
          d_a = _aa
        elseif b_a == PRED_TWO_HITS then
          local aaa = 0
          if DamagePredictionMenu.laneClearType == 1 then
            aaa = Orbwalker:GetAnimationTime() + GetDistance(a_a.pos, myHero.pos) / MyHero.ProjectileSpeed - 0.07
            aaa = aaa * 2
          elseif DamagePredictionMenu.laneClearType == 2 then
            aaa = Orbwalker:GetWindUp() * 2 + Orbwalker:GetAnimationTime() * 2 + GetDistance(a_a.pos, myHero.pos) / MyHero.ProjectileSpeed - 0.07
          elseif DamagePredictionMenu.laneClearType == 3 then
            aaa = Orbwalker:GetAnimationTime() + GetDistance(a_a.pos, myHero.pos) / MyHero.ProjectileSpeed - 0.07
            aaa = aaa * 1.5
          end
          count = db:GetPredictedHealth2(a_a, aaa)
          _aa, _ = db:GetPredictedHealth2(a_a, aaa)
          d_a = _aa
        elseif b_a == PRED_SKILL then
          local aaa = self.Preds[a_a.networkID]
          if aaa and aaa.Skill and aaa.Skill[c_a.Key] then
            return aaa.Skill[c_a.Key]
          else
            local baa = c_a.Delay / 1000 + GetDistance(a_a.pos, myHero.pos) / (c_a.Speed * 1000) - 0.07
            count = db:GetPredictedHealth(a_a, baa, MenuManager:GetFarmOffset())
            _aa, _ = db:GetPredictedHealth(a_a, baa, MenuManager:GetFarmOffset())
            d_a = _aa
          end
        elseif b_a == PRED_UNKILLABLE then
          local aaa = Orbwalker:GetWindUp() + GetDistance(a_a.pos, myHero.pos) / MyHero.ProjectileSpeed - 0.07
          aaa = aaa * 1.5
          count = db:GetPredictedHealth(a_a, aaa, MenuManager:GetFarmOffset())
          _aa, _ = db:GetPredictedHealth(a_a, aaa, MenuManager:GetFarmOffset())
          d_a = _aa
        end
        return d_a
      end
      class("_Minions")
      Minions = nil
      function _Minions:__init()
        self.KillableMinion = nil
        self.AlmostKillable = nil
        self.AttackRangeBuffer = myHero.range + 50
        self.LastWait = 0
        self.LastMove = 0
        self.TowerHitTime = 0
        self.LowerLimit = -20
        self.Cannons = {}
        self.EnemyMinions = _MinManager(MINION_ENEMY, 2000, myHero, MINION_SORT_HEALTH_ASC)
        self.OtherMinions = _MinManager(MINION_OTHER, 2000, myHero, MINION_SORT_HEALTH_ASC)
        AddTickCallback(function()
          self:_OnTick()
        end)
        AddProcessSpellCallback(function(a_a, b_a)
          self:OnProcessSpell(a_a, b_a)
        end)
        Minions = self
      end
      function _Minions:_OnTick()
        self.AttackRangeBuffer = myHero.range + 50
      end
      function _Minions:MyDamage(a_a, b_a)
        local c_a = db:CalcDamageOfAttack(_ENV.myHero, a_a, {name = "Basic"}, 0) + self:BonusDamage(a_a)
        if _ENV.FarmMenu.LaneFreeze and not _ENV.Keys.LaneClear and not _ENV.Orbwalker:CanOrbwalkTarget(self.TowerTarget) then
          return c_a < 80 and c_a or 80
        else
          return c_a
        end
      end
      function _Minions:OnProcessSpell(a_a, b_a)
        if a_a and a_a.valid and b_a.target and a_a.type ~= myHero.type and b_a.target.type == "obj_AI_Minion" and a_a.team == myHero.team and b_a and a_a.type == "obj_AI_Turret" and GetDistance(b_a.target) <= 2000 then
          self.TowerTarget = b_a.target
        end
      end
      function _Minions:GetLaneClearTarget()
        for a_a, b_a in ipairs(self.EnemyMinions.objects) do
          local c_a = Orbwalker:GetAnimationTime() + GetDistance(b_a.pos, myHero.pos) / MyHero.ProjectileSpeed - 0.07
          local d_a = b_a.health - db:GetPredictedHealth(b_a, c_a, MenuManager:GetFarmOffset())
          local _aa = db:GetPredictedHealth2(b_a, c_a * 2)
          if Orbwalker:CanOrbwalkTarget(b_a) then
            if _aa > 2 * db:CalcDamageOfAttack(myHero, b_a, {name = "Basic"}, 0) + self:BonusDamage(b_a) or d_a == 0 then
              return b_a
            end
          end
        end
        self.OtherMinions:update()
        for a_a, b_a in ipairs(self.OtherMinions.objects) do
          if Orbwalker:CanOrbwalkTarget(b_a) then
            return b_a
          end
        end
        return Jungle:GetAttackableMonster()
      end
      function _Minions:ContainsTowerAttack(a_a)
        for b_a, c_a in pairs(db.ActiveAttacks) do
          if c_a.Target == a_a and c_a.Attacker.type == "obj_AI_Turret" then
            if c_a.Target.charName == "Red_Minion_MechCannon" or c_a.Target.charName == "Blue_Minion_MechCannon" then
              db.ActiveAttacks[b_a].damage = c_a.damage * 1.2
            end
            return c_a
          end
        end
        return false
      end
      local _d = 0
      local ad = 1
      local bd = 2
      local cd = {
        SRU_OrderMinionRanged = 650,
        SRU_ChaosMinionRanged = 650,
        SRU_OrderMinionMelee = math.huge,
        SRU_ChaosMinionMelee = math.huge,
        SRU_OrderMinionSiege = 1200,
        SRU_ChaosMinionSiege = 1200
      }
      function db:GetProjectileSpeed(a_a)
        if a_a and a_a.type == "obj_AI_Turret" then
          return 1200
        else
          return cd[a_a.charName] and cd[a_a.charName] or self.projectilespeeds[a_a.charName] and self.projectilespeeds[a_a.charName] or _ENV.math.huge
        end
      end
      function _Minions:GetTowerMinion()
        if Orbwalker:CanOrbwalkTarget(self.TowerTarget) then
          local a_a = self:ContainsTowerAttack(self.TowerTarget)
          if not a_a then
            return
          end
          local b_a = a_a.damage
          local c_a = a_a.hittime
          local d_a = self:MyDamage(self.TowerTarget)
          local _aa = db:GetPredictedHealth2(self.TowerTarget, c_a - a_a.starttime + 0.02) - b_a - 10
          if _aa < 0 then
            return self.TowerTarget, bd
          end
          if _aa > 0 and d_a > _aa then
            return nil
          end
          local aaa = Orbwalker:GetWindUp() + GetDistance(self.TowerTarget.pos, myHero.pos) / MyHero.ProjectileSpeed - 0.07
          if c_a > aaa then
            _aa = db:GetPredictedHealth2(self.TowerTarget, c_a - a_a.starttime + 0.02) - b_a - 10
            if _aa > 0 and _aa - d_a > 0 and d_a > _aa - d_a then
              return self.TowerTarget, _d
            end
          end
          if _aa > 0 and _aa > d_a * 2 + b_a then
            return self.TowerTarget, bd
          end
        end
      end
      function _Minions:WaitForCannon()
        local a_a = {}
        for b_a, c_a in pairs(self.EnemyMinions.objects) do
          if Helper:GetDistance(c_a) <= 2000 and Data:IsCannonMinion(c_a) then
            table.insert(a_a, c_a)
          end
        end
        for b_a, c_a in pairs(a_a) do
          if Orbwalker:CanOrbwalkTargetCustomRange(c_a, self.AttackRangeBuffer) and DamagePred:GetPred(c_a, PRED_TWO_HITS) < self:MyDamage(c_a) then
            return c_a
          end
        end
      end
      function _Minions:FindUnkillable()
        local a_a = self:WaitForCannon()
        if a_a and DamagePred:GetPred(a_a, PRED_UNKILLABLE) < self:MyDamage(a_a) and minion ~= self.LastHitMinion then
          local b_a = DamagePred:GetPred(a_a, PRED_UNKILLABLE)
          if b_a < 0 then
            return a_a
          end
        end
        for b_a, c_a in ipairs(self.EnemyMinions.objects) do
          if c_a ~= self.LastHitMinion then
            local d_a = DamagePred:GetPred(c_a, PRED_UNKILLABLE)
            if d_a < 0 then
              return c_a
            end
          end
        end
      end
      function _Minions:FindKillable()
        local a_a = self:WaitForCannon()
        if a_a then
          if Orbwalker:CanOrbwalkTarget(a_a, self.AttackRangeBuffer) and DamagePred:GetPred(a_a, PRED_LAST_HIT) < self:MyDamage(a_a) then
            local b_a = self:MyDamage(a_a)
            local c_a = DamagePred:GetPred(a_a, PRED_LAST_HIT)
            if b_a > c_a and c_a > self.LowerLimit then
              return a_a
            end
          end
          return
        end
        for b_a, c_a in ipairs(self.EnemyMinions.objects) do
          local d_a = DamagePred:GetPred(c_a, PRED_LAST_HIT)
          local _aa = self:MyDamage(c_a)
          if Orbwalker:CanOrbwalkTarget(c_a) and d_a < _aa and d_a > self.LowerLimit then
            self.LastHitMinion = c_a
            return c_a
          end
        end
      end
      function _Minions:ShouldWait()
        for a_a, b_a in ipairs(self.EnemyMinions.objects) do
          local c_a = self:MyDamage(b_a)
          local d_a = DamagePred:GetPred(b_a, PRED_TWO_HITS)
          if self.TowerTarget and b_a == self.TowerTarget and (b_a.charName == "Red_Minion_MechCannon" or b_a.charName == "Blue_Minion_MechCannon") and b_a.health / b_a.maxHealth > 0.4 then
            return nil
          end
          if Orbwalker:CanOrbwalkTarget(b_a, self.AttackRangeBuffer) and c_a > d_a then
            self.LastWait = Helper:GetTime()
            self.LastWaitedFor = b_a
            return b_a
          end
        end
      end
      function _Minions:TowerFarm()
        if ConfigurationMenu.SupportMode then
          Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
          return
        end
        _type = self:GetTowerMinion()
        target = self:GetTowerMinion()
        if target and _type == _d then
          Orbwalker:Orbwalk(target)
          return
        end
        if SkillsMenu and SkillsMenu.SkillFarm and SkillsMenu.FarmMinMana and myHero.mana / myHero.maxMana * 100 >= SkillsMenu.FarmMinMana then
          local a_a, b_a = self:GetKillableSkillMinion(true)
          if a_a then
            self:CastOnMinion(a_a, b_a)
          end
        end
        if Orbwalker:CanOrbwalkTarget(self.KillableMinion) then
          Orbwalker:Orbwalk(self.KillableMinion)
          return
        end
        if target and _type == ad then
          self:LastHitWithSkill(target)
          return
        end
        self.EnemyMinions:update()
        self.KillableMinion = self:FindKillable()
        if target and _type == bd and Keys.LaneClear then
          self:LaneClear(true)
          return
        end
        MyHero:Move()
      end
      function _Minions:MixedMode()
        if not MixedModeMenu.MinionPriority and Orbwalker:CanOrbwalkTarget(Crosshair.Attack_Crosshair.target) then
          Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
          return
        end
        if ConfigurationMenu.SupportMode then
          Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
          return
        end
        if ValidTarget(self.TowerTarget) and Orbwalker:CanOrbwalkTargetCustomRange(self.TowerTarget, myHero.range + 150) then
          self:TowerFarm()
          return
        end
        if Orbwalker:CanOrbwalkTarget(self.KillableMinion) then
          Orbwalker:Orbwalk(self.KillableMinion)
          return
        end
        self.EnemyMinions:update()
        self.KillableMinion = self:FindKillable()
        if Helper:GetTime() > self.LastWait + 500 then
          self.AlmostKillable = self:ShouldWait()
        end
        if Orbwalker:CanOrbwalkTarget(self.AlmostKillable) then
          MyHero:Move()
          return
        end
        if Orbwalker:CanOrbwalkTarget(Crosshair.Attack_Crosshair.target) then
          Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
          return
        end
        MyHero:Move()
      end
      function _Minions:LaneClear(a_a)
        if not LaneClearMenu.MinionPriority and LaneClearMenu.AttackEnemies and Orbwalker:CanOrbwalkTarget(Crosshair.Attack_Crosshair.target) then
          Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
          return
        end
        if ConfigurationMenu.SupportMode then
          Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
          return
        end
        if ValidTarget(self.TowerTarget) and not a_a and Orbwalker:CanOrbwalkTargetCustomRange(self.TowerTarget, myHero.range + 300) then
          self:TowerFarm()
          return
        end
        if Orbwalker:CanOrbwalkTarget(self.KillableMinion) and Orbwalker:CanShoot() then
          Orbwalker:Orbwalk(self.KillableMinion)
          return
        end
        self.EnemyMinions:update()
        self.KillableMinion = self:FindKillable()
        if SkillsMenu and SkillsMenu.SkillFarm and SkillsMenu.FarmMinMana and myHero.mana / myHero.maxMana * 100 >= SkillsMenu.FarmMinMana then
          local c_a, d_a = self:GetKillableSkillMinion(true)
          if c_a then
            self:CastOnMinion(c_a, d_a)
          end
        end
        if Orbwalker:CanOrbwalkTarget(self.KillableMinion) then
          Orbwalker:Orbwalk(self.KillableMinion)
          return
        end
        if Helper:GetTime() > self.LastWait + 500 then
          self.AlmostKillable = self:ShouldWait()
        end
        if Orbwalker:CanOrbwalkTarget(self.AlmostKillable) then
          MyHero:Move()
          return
        end
        if Structures:CanOrbwalkStructure() and ConfigurationMenu.AttackStructures then
          Orbwalker:OrbwalkIgnoreChecks(Structures:GetTargetStructure())
          return
        end
        if LaneClearMenu.AttackEnemies and Orbwalker:CanOrbwalkTarget(Crosshair.Attack_Crosshair.target) then
          Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
          return
        end
        local b_a = self:GetLaneClearTarget()
        if SkillsMenu and SkillsMenu.SkillFarm and Data:IsJungleMinion(b_a) then
          for c_a, d_a in pairs(Skills.SkillsList) do
            if SkillsMenu[d_a.RawName] and SkillsMenu[d_a.RawName].Jungle then
              d_a:Cast(b_a)
            end
          end
        end
        Orbwalker:Orbwalk(b_a)
      end
      function _Minions:LastHit()
        if ConfigurationMenu.SupportMode then
          Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
          return
        end
        if ValidTarget(self.TowerTarget) then
          self:TowerFarm()
          return
        end
        if Orbwalker:CanOrbwalkTarget(self.KillableMinion) then
          Orbwalker:Orbwalk(self.KillableMinion)
          return
        end
        self.EnemyMinions:update()
        self.KillableMinion = self:FindKillable()
        MyHero:Move()
      end
      function _Minions:MarkerOnly()
        if not Orbwalker:CanOrbwalkTarget(self.KillableMinion) then
          self.EnemyMinions:update()
          self.KillableMinion = self:FindKillable()
          if not self.Killable and Helper:GetTime() > self.LastWait + 500 then
            self.AlmostKillable = self:ShouldWait()
          end
        end
      end
      function _Minions:CastOnMinion(a_a, b_a)
        local c_a = ""
        if b_a.Key == _Q then
          c_a = "Q"
        elseif b_a.Key == _W then
          c_a = "W"
        elseif b_a.Key == _E then
          c_a = "E"
        elseif b_a.Key == _R then
          c_a = "R"
        end
        if ValidTarget(a_a, b_a.Range) then
          if b_a.Type == SPELL_TARGETED then
            CastSpell(b_a.Key, a_a)
          elseif b_a.Type == SPELL_SELF_AT_MOUSE then
            CastSpell(b_a.Key, a_a.x, a_a.z)
          elseif b_a.Type == SPELL_LINEAR then
            b_a:Cast(a_a)
          elseif b_a.Type == SPELL_LINEAR_COL then
            local d_a = b_a:GetLinePrediction(a_a)
            if d_a then
              CastSpell(b_a.Key, d_a.x, d_a.z)
            end
          else
            CastSpell(b_a.Key)
          end
        end
      end
      function _Minions:GetKillableSkillMinion(a_a, b_a)
        for c_a, d_a in ipairs(self.EnemyMinions.objects) do
          if d_a ~= self.GuaranteedDeadMinion then
            for _aa, aaa in pairs(Skills:GetLastHitSkills()) do
              local baa = ""
              if aaa.Key == _Q then
                baa = "Q"
              elseif aaa.Key == _W then
                baa = "W"
              elseif aaa.Key == _E then
                baa = "E"
              elseif aaa.Key == _R then
                baa = "R"
              end
              if not SkillsMenu[aaa.RawName].LaneClearFarm then
                return
              end
              if myHero:CanUseSpell(aaa.Key) == READY and ValidTarget(d_a, aaa.Range) then
                local caa = getDmg(baa, d_a, myHero)
                if aaa.Type == SPELL_LINEAR or aaa.Type == SPELL_LINEAR_COL then
                  local daa = DamagePred:GetPred(d_a, PRED_SKILL, aaa)
                  if caa > daa then
                    local _ba = aaa:GetLinePrediction(d_a)
                    if _ba then
                      return d_a, aaa
                    end
                  end
                elseif caa > d_a.health then
                  return d_a, aaa
                end
              end
            end
          end
          if b_a then
            return
          end
        end
      end
      function _Minions:PushWithSkills()
        for a_a, b_a in ipairs(self.EnemyMinions.objects) do
          if b_a ~= self.LastHitMinion then
            self:LastHitWithSkill(b_a, true)
          end
        end
      end
      function _Minions:BonusDamage(a_a)
        local b_a = myHero:CalcDamage(a_a, myHero.totalDamage)
        local c_a = 0
        if myHero.charName == "Vayne" then
          if 0 < myHero:GetSpellData(_Q).level and myHero:CanUseSpell(_Q) == SUPRESSED then
            c_a = c_a + myHero:CalcDamage(a_a, (0.05 * myHero:GetSpellData(_Q).level + 0.25) * myHero.totalDamage)
          end
          if not VayneCBAdded then
            VayneCBAdded = true
            function VayneParticle(d_a)
              if GetDistance(d_a) < 1000 and d_a.name:lower():find("vayne_w_ring2.troy") then
                VayneWParticle = d_a
              end
            end
            AddCreateObjCallback(VayneParticle)
          end
          if VayneWParticle and VayneWParticle.valid and GetDistance(VayneWParticle, a_a) < 10 then
            c_a = c_a + 10 + 10 * myHero:GetSpellData(_W).level + (0.03 + 0.01 * myHero:GetSpellData(_W).level) * a_a.maxHealth
          end
        elseif myHero.charName == "Teemo" and 0 < myHero:GetSpellData(_E).level then
          c_a = c_a + myHero:CalcMagicDamage(a_a, myHero:GetSpellData(_E).level * 10 + myHero.ap * 0.3)
        elseif myHero.charName == "Corki" then
          c_a = c_a + myHero.totalDamage / 10
        elseif myHero.charName == "MissFortune" and 0 < myHero:GetSpellData(_W).level then
          c_a = c_a + myHero:CalcMagicDamage(a_a, 4 + 2 * myHero:GetSpellData(_W).level + myHero.ap / 20)
        elseif myHero.charName == "Varus" and 0 < myHero:GetSpellData(_W).level then
          c_a = c_a + (6 + myHero:GetSpellData(_W).level * 4 + myHero.ap * 0.25)
        elseif myHero.charName == "Caitlyn" then
          if not CallbackCaitlynAdded then
            function CaitlynParticle(d_a)
              if GetDistance(d_a) < 100 and d_a.name:lower():find("headshot_rdy") then
                HeadShotParticle = d_a
              end
            end
            AddCreateObjCallback(CaitlynParticle)
            CallbackCaitlynAdded = true
          end
          if HeadShotParticle and HeadShotParticle.valid then
            c_a = c_a + b_a * 1.5
          end
        elseif myHero.charName == "Draven" then
          if not CallbackDravenAdded then
            Data:bind("OnGainBuff", function(d_a, _aa)
              if d_a.isMe and _aa.name == "dravenspinning" or _aa.name == "dravenspinningattack" then
                DravenQBuff = true
              end
            end)
            Data:bind("OnLoseBuff", function(d_a, _aa)
              if d_a.isMe and _aa.name == "dravenspinning" or _aa.name == "dravenspinningattack" then
                DravenQBuff = false
              end
            end)
            CallbackDravenAdded = true
          end
          c_a = c_a + (0 < myHero:GetSpellData(_Q).level and DravenQBuff and myHero.totalDamage * (0.35 + 0.1 * myHero:GetSpellData(_Q).level) or 0)
        elseif myHero.charName == "Orianna" then
          c_a = c_a + myHero:CalcMagicDamage(a_a, 10 + 8 * ((myHero.level - 1) % 3))
        elseif myHero.charName == "TwistedFate" then
          if not TFCallbackAdded then
            function TFParticle(d_a)
              if GetDistance(d_a) < 100 and d_a.name:lower():find("cardmaster_stackready.troy") then
                TFEParticle = d_a
              elseif GetDistance(d_a) < 100 and d_a.name:lower():find("card_blue.troy") then
                TFWParticle = d_a
              end
            end
            AddCreateObjCallback(TFParticle)
            TFCallbackAdded = true
          end
          if TFEParticle and TFEParticle.valid then
            c_a = c_a + myHero:CalcMagicDamage(a_a, myHero:GetSpellData(_E).level * 15 + 40 + 0.5 * myHero.ap)
          end
          if TFWParticle and TFWParticle.valid then
            c_a = c_a + math.max(myHero:CalcMagicDamage(a_a, myHero:GetSpellData(_W).level * 20 + 20 + 0.5 * myHero.ap) - 40, 0)
          end
        elseif myHero.charName == "Nasus" and VIP_USER and 0 < myHero:GetSpellData(_Q).level and myHero:CanUseSpell(_Q) == SUPRESSED then
          local d_a = {
            30,
            50,
            70,
            90,
            110
          }
          NasusQStacks = NasusQStacks or 0
          c_a = c_a + myHero:CalcDamage(a_a, 10 + 20 * myHero:GetSpellData(_Q).level + NasusQStacks)
          if not RecvPacketNasusAdded then
            function NasusOnRecvPacket(_aa)
              if _aa.header == 254 and _aa.size == 12 then
                _aa.pos = 1
                pNetworkID = _aa:DecodeF()
                unk01 = _aa:Decode2()
                unk02 = _aa:Decode1()
                stack = _aa:Decode4()
                if pNetworkID == myHero.networkID then
                  NasusQStacks = stack
                end
              end
            end
            RecvPacketNasusAdded = true
            AddRecvPacketCallback(NasusOnRecvPacket)
          end
        end
        return c_a
      end
      function _Minions:GetLowestHealthMinion()
        for i = 1, #self.EnemyMinions.objects do
          local a_a = self.EnemyMinions.objects[i]
          if Orbwalker:CanOrbwalkTarget(a_a) then
            return a_a
          end
        end
      end
      function _Minions:GetSecondLowestHealthMinion()
        local a_a
        for i = 1, #self.EnemyMinions.objects do
          local b_a = self.EnemyMinions.objects[i]
          if Orbwalker:CanOrbwalkTarget(b_a) and a_a then
            return b_a
          elseif Orbwalker:CanOrbwalkTarget(b_a) then
            a_a = b_a
          end
        end
        return a_a
      end
      class("_ChampionBuffs")
      ChampionBuffs = nil
      function _ChampionBuffs:__init()
        AddCreateObjCallback(function(a_a)
          self:_OnCreateObj(a_a)
        end)
        AddDeleteObjCallback(function(a_a)
          self:_OnDeleteObj(a_a)
        end)
        self.HasPassive = false
        self.RangerStacks = 0
        self.qBuff = 0
        ChampionBuffs = self
      end
      function _ChampionBuffs:_OnCreateObj(a_a)
        if myHero.dead then
          return
        end
        if a_a.name:lower():find("caitlyn_headshot_rdy") and Helper:GetDistance(a_a) < 65 then
          self.caitlynPassive = true
        end
        if a_a.name:lower():find("Lucian_P_buf.troy") and Helper:GetDistance(a_a) < 65 then
          self.LucianPassive = true
        end
        if a_a.name == "RengarPassiveMax.troy" and Helper:GetDistance(a_a) < 65 then
          self.rengarStacks = 5
        end
        if a_a.name == "RighteousFuryHalo_buf.troy" and Helper:GetDistance(a_a) < 65 then
          self.kayleBuff = true
        end
        if a_a.name == "Draven_Q_buf.troy" and Helper:GetDistance(a_a) < 65 then
          self.qBuff = self.qBuff >= 0 and self.qBuff + 1 or 0
        end
        if a_a.name == "Jayce_Hex_Buff_Ready.troy" and Helper:GetDistance(a_a) < 65 then
          self.jayceWcasted = true
        end
      end
      function _ChampionBuffs:_OnDeleteObj(a_a)
        if a_a.name:lower():find("caitlyn_headshot_rdy") and Helper:GetDistance(a_a) < 65 then
          self.caitlynPassive = false
        end
        if a_a.name:lower():find("Lucian_P_buf.troy") and Helper:GetDistance(a_a) < 65 then
          self.LucianPassive = true
        end
        if a_a.name == "Lucian_R_self.troy" and LucianCulling == true and Helper:GetDistance(a_a) < 65 then
          self.LucianCulling = false
        end
        if a_a.name == "RengarPassiveMax.troy" and Helper:GetDistance(a_a) < 65 then
          self.rengarStacks = 0
        end
        if a_a.name == "RighteousFuryHalo_buf.troy" and Helper:GetDistance(a_a) < 65 then
          self.kayleBuff = false
        end
        if a_a.name == "Draven_Q_buf.troy" and Helper:GetDistance(a_a) < 600 then
          self.qBuff = self.qBuff - 1
        end
        if a_a.name == "Jayce_Hex_Buff_Ready.troy" and Helper:GetDistance(a_a) < 65 then
          self.jayceWcasted = false
        end
      end
      function _ChampionBuffs:GetBonusDamage()
        local a_a = {
          Teemo = myHero:GetSpellData(_E).level > 0 and GetSpellData(_E).level * 10 + myHero.ap * 0.3 or 0,
          Vayne = 0 < myHero:GetSpellData(_Q).level and myHero:CanUseSpell(_Q) == SUPRESSED and (0.05 * myHero:GetSpellData(_Q).level + 0.25) * myHero.totalDamage or 0,
          Corki = myHero.totalDamage / 10,
          Caitlyn = self.caitlynPassive and myHero.totalDamage * 1.5 or 0,
          Rengar = 0 < myHero:GetSpellData(_Q).level and myHero:CanUseSpell(_Q) == SUPRESSED and (self.rengarStacks == 5 and 30 * myHero:GetSpellData(_Q).level + myHero.totalDamage or 30 * myHero:GetSpellData(_Q).level) or 0,
          MissFortune = 0 < myHero:GetSpellData(_W).level and 2 + 2 * myHero:GetSpellData(_W).level + myHero.ap * 0.05 or 0,
          Sivir = 0 < myHero:GetSpellData(_W).level and myHero:CanUseSpell(_W) == SUPRESSED and 5 + 15 * myHero:GetSpellData(_W).level or 0,
          Orianna = 8 * ((myHero.level - 1) / 3 + 1) + 2 + 0.15 * myHero.ap,
          Draven = 0 < myHero:GetSpellData(_Q).level and 0 < self.qBuff and myHero.totalDamage * (0.35 + 0.1 * myHero:GetSpellData(_Q).level) or 0,
          Kayle = self.kayleBuff and 10 + 10 * myHero:GetSpellData(_E).level + 0.4 * myHero.ap or 0,
          Jayce = self.jayceWcasted and myHero.totalDamage * (15 * myHero:GetSpellData(_W).level + 55) / 100 - myHero.totalDamage or 0,
          Lucian = self.LucianPassive and myHero.totalDamage or 0
        }
        return a_a[myHero.charName] or 0
      end
      class("_Jungle")
      Jungle = nil
      function _Jungle:__init()
        self.JungleMonsters = {}
        Jungle = self
        for i = 0, objManager.maxObjects do
          local a_a = objManager:getObject(i)
          if Data:IsJungleMinion(a_a) then
            table.insert(self.JungleMonsters, a_a)
          end
        end
        AddCreateObjCallback(function(a_a)
          self:_OnCreateObj(a_a)
        end)
        AddDeleteObjCallback(function(a_a)
          self:_OnDeleteObj(a_a)
        end)
      end
      function _Jungle:_OnCreateObj(a_a)
        if Data:IsJungleMinion(a_a) then
          table.insert(self.JungleMonsters, a_a)
        end
      end
      function _Jungle:_OnDeleteObj(a_a)
        if Data:IsJungleMinion(a_a) then
          for b_a, c_a in pairs(self.JungleMonsters) do
            if obj == a_a then
              table.remove(self.JungleMonsters, b_a)
            end
          end
        end
      end
      function _Jungle:GetJungleMonsters()
        return self.JungleMonsters
      end
      function _Jungle:GetAttackableMonster()
        local a_a
        local b_a = 0
        for c_a, d_a in pairs(self.JungleMonsters) do
          if Orbwalker:CanOrbwalkTarget(d_a) then
            local _aa = Data:GetJunglePriority(d_a.name)
            if d_a.health < MyHero:GetTotalAttackDamageAgainstTarget(d_a) then
              return d_a
            elseif not a_a then
              a_a = d_a
              b_a = _aa
            elseif _aa < b_a then
              a_a = d_a
              b_a = _aa
            end
          end
        end
        return a_a
      end
      function _Jungle:GetFocusedMonster()
        if GetTarget() and Data:IsJungleMinion(GetTarget()) then
          return GetTarget()
        end
      end
      class("_Structures")
      Structures = nil
      function _Structures:__init()
        Structures = self
        self.TowerCollisionRange = 88.4
        self.InhibCollisionRange = 205
        self.NexusCollisionRange = 300
        self.TowerRange = 775
        self.EnemyTowers = {}
        self.AllyTowers = {}
        for i = 1, objManager.maxObjects do
          local a_a = objManager:getObject(i)
          if a_a and a_a.type == "obj_AI_Turret" then
            if a_a.team == myHero.team then
              table.insert(self.AllyTowers, a_a)
            else
              table.insert(self.EnemyTowers, a_a)
            end
          end
        end
        AddDeleteObjCallback(function(a_a)
          self:_OnDeleteObj(a_a)
        end)
      end
      function _Structures:_OnDeleteObj(a_a)
        for b_a, c_a in pairs(self.AllyTowers) do
          if a_a == c_a then
            table.remove(self.AllyTowers, b_a)
            return
          end
        end
        for b_a, c_a in pairs(self.EnemyTowers) do
          if a_a == c_a then
            table.remove(self.EnemyTowers, b_a)
            return
          end
        end
      end
      function _Structures:TowerTargetted()
        return GetTarget() and GetTarget().type == "obj_AI_Turret" and GetTarget().team ~= myHero.team
      end
      function _Structures:InhibTargetted()
        return GetTarget() and GetTarget().type == "obj_BarracksDampener" and GetTarget().team ~= myHero.team
      end
      function _Structures:NexusTargetted()
        return GetTarget() and GetTarget().type == "obj_HQ" and GetTarget().team ~= myHero.team
      end
      function _Structures:CanOrbwalkStructure()
        return self:CanOrbwalkTower() or self:CanOrbwalkInhib() or self:CanOrbwalkNexus()
      end
      function _Structures:GetTargetStructure()
        return GetTarget()
      end
      function _Structures:CanOrbwalkTower()
        return self:TowerTargetted() and Helper:GetDistance(GetTarget()) - self.TowerCollisionRange < MyHero.TrueRange
      end
      function _Structures:CanOrbwalkInhib()
        return self:InhibTargetted() and Helper:GetDistance(GetTarget()) - self.InhibCollisionRange < MyHero.TrueRange
      end
      function _Structures:CanOrbwalkNexus()
        return self:NexusTargetted() and Helper:GetDistance(GetTarget()) - self.NexusCollisionRange < MyHero.TrueRange
      end
      function _Structures:PositionInEnemyTowerRange(a_a)
        for b_a, c_a in pairs(self.EnemyTowers) do
          if Helper:GetDistance(c_a, a_a) <= self.TowerRange then
            return true
          end
        end
        return false
      end
      function _Structures:PositionInAllyTowerRange(a_a)
        for b_a, c_a in pairs(self.AllyTowers) do
          if Helper:GetDistance(c_a, a_a) <= self.TowerRange then
            return true
          end
        end
        return false
      end
      function _Structures:GetClosestEnemyTower(a_a)
        local b_a, c_a = nil, 0
        for d_a, _aa in pairs(self.EnemyTowers) do
          if not _aa or not a_a then
            return
          end
          if not b_a then
            b_a, c_a = _aa, Helper:GetDistance(a_a, _aa)
          elseif c_a > Helper:GetDistance(a_a, _aa) then
            b_a, c_a = _aa, Helper:GetDistance(a_a, _aa)
          end
        end
        return b_a
      end
      function _Structures:GetClosestAllyTower(a_a)
        local b_a, c_a = nil, 0
        for d_a, _aa in pairs(self.AllyTowers) do
          if not b_a then
            b_a, c_a = _aa, Helper:GetDistance(a_a, _aa)
          elseif c_a > Helper:GetDistance(a_a, _aa) then
            b_a, c_a = _aa, Helper:GetDistance(a_a, _aa)
          end
        end
        return b_a
      end
      class("_Skills")
      Skills = nil
      function _Skills:__init()
        self.SkillsList = {}
        Skills = self
        AddTickCallback(function()
          self:_OnTick()
        end)
      end
      function _Skills:_OnTick()
        for a_a, b_a in pairs(self.SkillsList) do
          if not b_a.IsCustom then
            if Keys.AutoCarry and SkillsMenu[b_a.RawName].AutoCarry or Keys.MixedMode and SkillsMenu[b_a.RawName].MixedMode or Keys.LaneClear and SkillsMenu[b_a.RawName].LaneClear then
              b_a.Active = true
            else
              b_a.Active = false
            end
            b_a.Killsteal = SkillsMenu[b_a.RawName] and SkillsMenu[b_a.RawName].Killsteal or false
          end
        end
        self:Killsteal()
      end
      function _Skills:CastAll(a_a)
        for b_a, c_a in ipairs(self.SkillsList) do
          if c_a.Enabled then
            c_a:Cast(a_a)
          end
        end
      end
      function _Skills:GetSkill(a_a)
        for b_a, c_a in pairs(self.SkillsList) do
          if c_a.Key == a_a then
            return c_a
          end
        end
      end
      function _Skills:HasSkillReady()
        for a_a, b_a in pairs(self.SkillsList) do
          if b_a.Ready then
            return true
          end
        end
      end
      function _Skills:NewSkill(a_a, b_a, c_a, d_a, _aa, aaa, baa, caa, daa, _ba, aba, bba, cba)
        return _Skill(a_a, b_a, c_a, d_a, _aa, aaa, baa, caa, daa, _ba, aba, bba, cba, true)
      end
      function _Skills:DisableAll()
        for a_a, b_a in pairs(self.SkillsList) do
          b_a.Enabled = false
        end
      end
      function _Skills:GetLastHitSkills()
        local a_a = {}
        for b_a, c_a in pairs(self.SkillsList) do
          if c_a.Type == SPELL_TARGETED or c_a.IsReset or c_a.Type == SPELL_LINEAR_COL or c_a.Type == SPELL_LINEAR then
            table.insert(a_a, c_a)
          end
        end
        return a_a
      end
      function _Skills:Killsteal()
        for a_a, b_a in pairs(GetEnemyHeroes()) do
          for c_a, d_a in pairs(self.SkillsList) do
            local _aa = ""
            if d_a.Key == _Q then
              _aa = "Q"
            elseif d_a.Key == _W then
              _aa = "W"
            elseif d_a.Key == _E then
              _aa = "E"
            elseif d_a.Key == _R then
              _aa = "R"
            end
            if d_a.Killsteal and ValidTarget(b_a, d_a.Range) and b_a.health < getDmg(_aa, b_a, myHero) then
              d_a:Cast(b_a, true)
            end
          end
        end
      end
      class("_Skill")
      SPELL_TARGETED = 1
      SPELL_LINEAR = 2
      SPELL_CIRCLE = 3
      SPELL_CONE = 4
      SPELL_LINEAR_COL = 5
      SPELL_SELF = 6
      SPELL_SELF_AT_MOUSE = 7
      AutoCarry.SPELL_TARGETED = 1
      AutoCarry.SPELL_LINEAR = 2
      AutoCarry.SPELL_CIRCLE = 3
      AutoCarry.SPELL_CONE = 4
      AutoCarry.SPELL_LINEAR_COL = 5
      AutoCarry.SPELL_SELF = 6
      AutoCarry.SPELL_SELF_AT_MOUSE = 7
      function _Skill:__init(a_a, b_a, c_a, d_a, _aa, aaa, baa, caa, daa, _ba, aba, bba, cba, dba, _ca)
        self.Key = b_a
        self.Range = c_a
        self.DisplayName = d_a
        self.RawName = self.DisplayName:gsub("[^A-Za-z0-9]", "")
        self.Type = _aa
        self.MinMana = aaa or 0
        self.AfterAttack = baa or false
        self.ReqAttackTarget = caa or false
        self.Speed = daa or 0
        self.Delay = _ba or 0
        self.Width = aba or 0
        self.Collision = bba
        self.IsReset = cba or false
        self.IsCustom = dba
        self.Active = true
        self.Enabled = a_a or false
        self.Ready = false
        self.Killsteal = false
        self.Conditional = _ca
        AddTickCallback(function()
          self:_OnTick()
        end)
        table.insert(Skills.SkillsList, self)
      end
      function _Skill:_OnTick()
        self.Ready = myHero:CanUseSpell(self.Key) == READY
      end
      function _Skill:Cast(a_a, b_a)
        if not b_a then
          if (not self.Active and self.Enabled or not self.Enabled and not self.IsCustom) and a_a.type == myHero.type then
            return
          elseif self.AfterAttack and not Orbwalker:IsAfterAttack() then
            return
          elseif self.ReqAttackTarget and not Orbwalker:CanOrbwalkTarget(a_a) then
            return
          end
        end
        if not self:IsReady() or self.Conditional and not self:Conditional(a_a) or MyHero.IsChannelling or Orbwalker:IsShooting() then
          return
        end
        if self.Type == SPELL_SELF and ValidTarget(a_a, self.Range) then
          CastSpell(self.Key)
        elseif self.Type == SPELL_SELF_AT_MOUSE then
          CastSpell(self.Key, mousePos.x, mousePos.z)
        elseif self.Type == SPELL_TARGETED then
          if ValidTarget(a_a, self.Range) then
            CastSpell(self.Key, a_a)
          end
        elseif self.Type == SPELL_LINEAR or self.Type == SPELL_LINEAR_COL or self.Type == SPELL_CONE then
          if ValidTarget(a_a) then
            local c_a = self:GetPrediction(a_a, true, b_a)
            if c_a and GetDistance(c_a) <= self.Range then
              CastSpell(self.Key, c_a.x, c_a.z)
            end
          end
        elseif self.Type == SPELL_CIRCLE and ValidTarget(a_a) then
          local c_a = self:GetPrediction(a_a, false, b_a)
          if c_a and GetDistance(c_a) <= self.Range then
            CastSpell(self.Key, c_a.x, c_a.z)
          end
        end
      end
      function _Skill:ForceCast(a_a)
        self:Cast(a_a, true)
      end
      function _Skill:GetPrediction(a_a, b_a, c_a)
        if not ValidTarget(a_a) then
          return
        end
        local d_a = false
        if self.Collision or self.Type == SPELL_LINEAR_COL then
          d_a = true
        end
        if c_a then
          d_a = false
        end
        if VIP_USER then
          if b_a then
            Position = db:GetLineCastPosition(a_a, self.Delay / 1000, self.Width, self.Range, self.Speed * 1000, myHero, d_a)
            HitChance = db:GetLineCastPosition(a_a, self.Delay / 1000, self.Width, self.Range, self.Speed * 1000, myHero, d_a)
            CastPosition = db:GetLineCastPosition(a_a, self.Delay / 1000, self.Width, self.Range, self.Speed * 1000, myHero, d_a)
          else
            Position = db:GetCircularCastPosition(a_a, self.Delay / 1000, self.Width, self.Range, self.Speed * 1000, myHero, d_a)
            HitChance = db:GetCircularCastPosition(a_a, self.Delay / 1000, self.Width, self.Range, self.Speed * 1000, myHero, d_a)
            CastPosition = db:GetCircularCastPosition(a_a, self.Delay / 1000, self.Width, self.Range, self.Speed * 1000, myHero, d_a)
          end
          if HitChance >= 2 then
            return CastPosition
          end
        elseif not VIP_USER then
          pred = TargetPrediction(self.Range, self.Speed, self.Delay, self.Width)
          pred = pred:GetPrediction(a_a)
          if d_a then
            local _aa = self:GetCollision(pred)
            if not _aa then
              return pred
            end
          else
            return pred
          end
        end
      end
      function _Skill:GetLinePrediction(a_a)
        return self:GetPrediction(a_a, true)
      end
      function _Skill:GetCirclePrediction(a_a)
        return self:GetPrediction(a_a, false)
      end
      function _Skill:GetCollision(a_a)
        if VIP_USER and self.Collision then
          local b_a = Collision(self.Range, self.Speed * 1000, self.Delay / 1000, self.Width)
          return b_a:GetMinionCollision(myHero, a_a)
        elseif self.Collision then
          for b_a, c_a in pairs(Minions.EnemyMinions.objects) do
            if ValidTarget(c_a) and myHero.x ~= c_a.x then
              local d_a = myHero.x
              local _aa = myHero.z
              local aaa = a_a.x
              local baa = a_a.z
              local caa = d_a - aaa
              local daa = _aa - baa
              local _ba = daa / caa
              local aba = d_a - _ba * d_a
              local bba = c_a.x
              local cba = c_a.z
              local dba = math.abs(cba - _ba * bba - aba) / math.sqrt(_ba * _ba + 1)
              if dba < self.Width and (aaa - d_a) * (aaa - d_a) + (baa - _aa) * (baa - _aa) > (aaa - bba) * (aaa - bba) + (baa - cba) * (baa - cba) then
                return true
              end
            end
          end
          return false
        end
      end
      function _Skill:GetHitChance(a_a)
        if VIP_USER then
          return a_a:GetHitChance(target) > ConfigMenu.HitChance / 100
        end
      end
      function _Skill:GetRange()
        return self.reqAttackTarget and MyHero.TrueRange or self.Range
      end
      function _Skill:IsReady()
        return myHero:CanUseSpell(self.Key) == READY
      end
      class("_Items")
      Items = nil
      function _Items:__init()
        self.ItemList = {}
        Items = self
        AddTickCallback(function()
          self:_OnTick()
        end)
      end
      function _Items:_OnTick()
        for a_a, b_a in pairs(self.ItemList) do
          if Keys.AutoCarry and AutoCarryMenu[b_a.RawName .. "AutoCarry"] or Keys.MixedMode and MixedModeMenu[b_a.RawName .. "MixedMode"] or Keys.LaneClear and LaneClearMenu[b_a.RawName .. "LaneClear"] then
            b_a.Active = true
          else
            b_a.Active = false
          end
        end
      end
      function _Items:UseAll(a_a)
        if a_a and a_a.type == myHero.type then
          for b_a, c_a in pairs(self.ItemList) do
            c_a:Use(a_a)
          end
        end
      end
      function _Items:UseItem(a_a, b_a)
        for c_a, d_a in pairs(self.ItemList) do
          if d_a.ID == a_a then
            d_a:Use(b_a)
          end
        end
      end
      function _Items:GetItem(a_a)
        for b_a, c_a in pairs(self.ItemList) do
          if c_a.ID == a_a then
            return c_a
          end
        end
      end
      function _Items:GetBotrkBonusLastHitDamage(a_a, b_a)
        local c_a = 0
        if GetInventoryHaveItem(3153) and ValidTarget(b_a) then
          c_a = b_a.health / 20
          if c_a >= 60 then
            c_a = 60
          end
        end
        return c_a
      end
      class("_Item")
      function _Item:__init(a_a, b_a, c_a, d_a, _aa, aaa)
        self.Name = a_a
        self.RawName = self.Name:gsub("[^A-Za-z0-9]", "")
        self.ID = c_a
        self.InternalName = b_a
        self.RequiresTarget = d_a
        self.Range = _aa
        self.Slot = nil
        self.Override = aaa
        self.Active = true
        self.Enabled = true
        table.insert(Items.ItemList, self)
      end
      function _Item:GetSlot()
        for slot = ITEM_1, ITEM_7 do
          local a_a = myHero:GetSpellData(slot).name
          if #a_a > 0 and a_a:lower() == self.InternalName:lower() then
            return slot
          end
        end
      end
      function _Item:Use(a_a)
        if self.Override then
          return self.Override()
        end
        if self.RequiresTarget and not a_a then
          return
        end
        if not self.Active or not self.Enabled then
          return
        end
        if MyHero.IsChannelling then
          return
        end
        self.Slot = self:GetSlot()
        if self.Slot then
          if self.ID == 3153 then
            local b_a = MenuManager:GetActiveMenu()
            if b_a and b_a.botrkSave then
              if myHero.health <= myHero.maxHealth * 0.65 then
                CastSpell(self.Slot, a_a)
              end
            elseif b_a and b_a.Active then
              CastSpell(self.Slot, a_a)
            end
          elseif self.ID == 3042 then
            if not MuramanaIsActive() then
              MuramanaOn()
            end
          elseif self.ID == 3069 then
            if Helper:CountAlliesInRange(600) > 0 then
              CastSpell(self.Slot)
            end
          elseif not self.RequiresTarget and Orbwalker:CanOrbwalkTarget(a_a) then
            CastSpell(self.Slot)
          elseif self.RequiresTarget and ValidTarget(a_a) and Helper:GetDistance(a_a) <= self.Range then
            CastSpell(self.Slot, a_a)
          end
        end
      end
      class("_Helper")
      Helper = nil
      function _Helper:__init()
        self.Tick = 0
        self.Latency = 0
        self.Colour = {Green = 65280}
        self.EnemyTable = {}
        Helper = self
        self.EnemyTable = GetEnemyHeroes()
        self.AllyTable = GetAllyHeroes()
        self.AllHeroes = {}
        self:GetAllHeroes()
        self.DebugStrings = {}
        AddTickCallback(function()
          self:_OnTick()
        end)
        AddDrawCallback(function()
          self:_OnDraw()
        end)
      end
      function _Helper:_OnTick()
        self.Tick = Helper:GetTime()
        self.Latency = GetLatency()
      end
      function _Helper:GetTime()
        return os.clock() * 1000
      end
      function _Helper:GetDistance(a_a, b_a)
        b_a = b_a or myHero
        if a_a.type == myHero.type then
          a_a = a_a.pos
        end
        if b_a.type == myHero.type then
          b_a = b_a.pos
        end
        return math.sqrt(GetDistanceSqr(a_a, b_a))
      end
      function _Helper:StringContains(a_a, b_a)
        return a_a:lower():find(b_a)
      end
      function _Helper:DrawCircleObject(a_a, b_a, c_a, d_a)
        if not a_a then
          return
        end
        if not d_a or not d_a then
          d_a = 0
        end
        for i = 0, d_a do
          if DrawingMenu.LowFPSCir then
            self:DrawCircle2(a_a.x, a_a.y, a_a.z, b_a + i, c_a)
          else
            DrawCircle(a_a.x, a_a.y, a_a.z, b_a + i, c_a)
          end
        end
      end
      function _Helper:DrawCircleNextLvl(a_a, b_a, c_a, d_a, _aa, aaa, baa)
        d_a = d_a or 300
        quality = math.max(8, self:round(180 / math.deg((math.asin(baa / (2 * d_a))))))
        quality = 2 * math.pi / quality
        d_a = d_a * 0.92
        local caa = {}
        for theta = 0, 2 * math.pi + quality, quality do
          local daa = WorldToScreen(D3DXVECTOR3(a_a + d_a * math.cos(theta), b_a, c_a - d_a * math.sin(theta)))
          caa[#caa + 1] = D3DXVECTOR2(daa.x, daa.y)
        end
        if DrawLines2 then
          DrawLines2(caa, _aa or 1, aaa or 4294967295)
        end
      end
      function _Helper:round(a_a)
        if a_a >= 0 then
          return math.floor(a_a + 0.5)
        else
          return math.ceil(a_a - 0.5)
        end
      end
		function _Helper:DrawCircle2(x, y, z, radius, color)
		    local vPos1 = Vector(x, y, z)
		    local vPos2 = Vector(cameraPos.x, cameraPos.y, cameraPos.z)
		    local tPos = vPos1 - (vPos1 - vPos2):normalized() * radius
		    local sPos = WorldToScreen(D3DXVECTOR3(tPos.x, tPos.y, tPos.z))
		    if OnScreen({ x = sPos.x, y = sPos.y }, { x = sPos.x, y = sPos.y }) then
		        self:DrawCircleNextLvl(x, y, z, radius, 1, color, 75)	
		    end
		end
      function _Helper:GetHitBoxDistance(a_a)
        return Helper:GetDistance(a_a) - Helper:GetDistance(a_a, a_a.minBBox)
      end
      function _Helper:TrimString(a_a)
        return a_a:find("^%s*$") and "" or a_a:match("^%s*(.*%S)")
      end

      function _Helper:ArgbFromMenu(a_a)
        return ARGB(a_a[1], a_a[2], a_a[3], a_a[4])
      end
      function _Helper:DecToHex(a_a)
        local b_a, c_a, d_a, _aa, aaa = 16, "0123456789ABCDEF", "", 0, nil
        while a_a > 0 do
          _aa = _aa + 1
          a_a, aaa = math.floor(a_a / b_a), math.fmod(a_a, b_a) + 1
          d_a = string.sub(c_a, aaa, aaa) .. d_a
        end
        return d_a
      end
      function _Helper:HexFromMenu(a_a)
        local b_a = {}
        b_a.a = a_a[1]
        b_a.r = a_a[2]
        b_a.g = a_a[3]
        b_a.b = a_a[4]
        return tonumber(self:DecToHex(b_a.a) .. self:DecToHex(b_a.r) .. self:DecToHex(b_a.g) .. self:DecToHex(b_a.b), 16)
      end
      function _Helper:IsEvading()
        return not _G.evade and not _G.Evade and _G.EzEvade and _G.EzEvade.Evading
      end
      function _Helper:GetAllHeroes()
        for i = 1, heroManager.iCount do
          local a_a = heroManager:GetHero(i)
          table.insert(self.AllHeroes, a_a)
        end
      end
      function _Helper:Debug(a_a)
        table.insert(self.DebugStrings, a_a)
      end
      function _Helper:_OnDraw()
        local a_a = 200
        for b_a, c_a in pairs(self.DebugStrings) do
          DrawText(tostring(c_a), 15, 100, a_a, 4294967040)
          a_a = a_a + 20
        end
        self.DebugStrings = {}
      end
      function _Helper:CountAlliesInRange(a_a)
        local b_a = 0
        for c_a, d_a in pairs(GetAllyHeroes()) do
          if d_a ~= myHero and a_a >= Helper:GetDistance(d_a) then
            b_a = b_a + 1
          end
        end
        return b_a
      end
      class("_Wards")
      _ENV.Wards = nil
      function _ENV._Wards:__init()
        self.EnemyWards = {}
        self.IncomingWards = {}
        self.AllyIncomingWards = {}
        self.PlacedWards = {}
        AddTickCallback(function()
          self:_OnTick()
        end)
        AddCreateObjCallback(function(a_a)
          self:_OnCreateObj(a_a)
        end)
        AddDeleteObjCallback(function(a_a)
          self:_OnDeleteObj(a_a)
        end)
        AddProcessSpellCallback(function(a_a, b_a)
          self:_OnProcessSpell(a_a, b_a)
        end)
        AddRecvPacketCallback(function(a_a)
          self:_OnReceivePacket(a_a)
        end)
        AdvancedCallback:bind("OnGainFocs")
        Plugins:RegisterPreAttack(function(a_a)
          self:PreAttack(a_a)
        end)
        Wards = self
      end
      function _ENV._Wards:_OnReceivePacket(a_a)
        if a_a.header == 49 then
          a_a.pos = 1
          local b_a = a_a:DecodeF()
          local c_a = a_a:DecodeF()
          for d_a, _aa in pairs(self.PlacedWards) do
            if _aa and b_a and d_a == b_a and _aa.vanga == 1 and Helper:GetTime() - _aa.spawnTime > 200 then
              self.PlacedWards[d_a] = nil
            elseif _aa and b_a and d_a == b_a and _aa.vanga == 2 and c_a == 0 then
              self.PlacedWards[d_a] = nil
            end
          end
        end
        if a_a.header == 180 then
          a_a.pos = 12
          local b_a = a_a:Decode1()
          a_a.pos = 1
          local c_a = a_a:DecodeF()
          a_a.pos = a_a.pos + 20
          local d_a = a_a:DecodeF()
          a_a.pos = 37
          local _aa = a_a:DecodeF()
          local aaa = a_a:DecodeF()
          local baa = a_a:DecodeF()
          local caa = a_a:DecodeF()
          local daa = a_a:DecodeF()
          local _ba = a_a:DecodeF()
          local aba = a_a:DecodeF()
          a_a:DecodeF()
          local bba = a_a:Decode1()
          a_a.pos = a_a.pos + 4
          local cba = a_a:Decode1()
          a_a.pos = 13
          local dba = a_a:Decode1()
          local _ca = DwordToFloat(AddNum(FloatToDword(_aa), 2))
          local aca = objManager:GetObjectByNetworkId(c_a)
          local bca, cca
          if aca and aca.team ~= myHero.team then
            return
          end
          if bba == 63 and cba == 51 and dba ~= 12 and dba ~= 48 then
            if b_a == 110 then
              self.PlacedWards[_ca] = {
                x = daa,
                y = _ba,
                z = aba,
                visionRange = 1100,
                spawnTime = Helper:GetTime(),
                duration = 60000,
                vanga = 1
              }
            elseif b_a == 46 then
              self.PlacedWards[_ca] = {
                x = daa,
                y = _ba,
                z = aba,
                visionRange = 1100,
                spawnTime = Helper:GetTime(),
                duration = 120000,
                vanga = 1
              }
            elseif b_a == 174 then
              self.PlacedWards[_ca] = {
                x = daa,
                y = _ba,
                z = aba,
                visionRange = 1100,
                spawnTime = Helper:GetTime(),
                duration = 180000,
                vanga = 1
              }
            elseif b_a == 238 then
              self.PlacedWards[_ca] = {
                x = daa,
                y = _ba,
                z = aba,
                visionRange = 1100,
                spawnTime = Helper:GetTime(),
                duration = 180000,
                vanga = 1
              }
            elseif dba == 8 or b_a == 126 then
              self.PlacedWards[_ca] = {
                x = daa,
                y = _ba,
                z = aba,
                visionRange = 1100,
                spawnTime = Helper:GetTime(),
                duration = 180000,
                vanga = 1
              }
            else
              self.PlacedWards[_ca] = {
                x = daa,
                y = _ba,
                z = aba,
                visionRange = 1100,
                spawnTime = Helper:GetTime(),
                duration = 180000,
                vanga = 1
              }
            end
          end
        end
        a_a.pos = 1
      end
      function _ENV._Wards:_OnTick()
        if self.LastWardAttacked and Helper:GetTime() > self.LastWardAttacked.Time + 100 and self.LastWardAttacked.LastAttack == Orbwalker.LastAttack then
          for a_a, b_a in pairs(self.EnemyWards) do
            if b_a == self.LastWardAttacked.Object then
              table.remove(self.EnemyWards, a_a)
              self.LastWardAttacked = nil
              return
            end
          end
        end
      end
      function _ENV._Wards:_OnProcessSpell(a_a, b_a)
        if Data:IsWardSpell(b_a) then
          if a_a.team ~= myHero.team then
            table.insert(self.IncomingWards, b_a.endPos)
          else
            table.insert(self.AllyIncomingWards, b_a.endPos)
          end
        end
      end
      function _ENV._Wards:_OnCreateObj(a_a)
        if a_a and Data:IsWard(a_a) then
          for b_a, c_a in pairs(self.IncomingWards) do
            if Helper:GetDistance(c_a, a_a) < 50 then
              table.insert(self.EnemyWards, a_a)
              table.remove(self.IncomingWards, b_a)
              return
            end
          end
          for b_a, c_a in pairs(self.PlacedWards) do
            if Helper:GetDistance(c_a, a_a) < 50 then
              table.remove(self.AllyIncomingWards, b_a)
              return
            end
          end
          table.insert(self.EnemyWards, a_a)
        end
      end
      function _ENV._Wards:PreAttack(a_a)
        if not self.LastWardAttacked then
          for b_a, c_a in pairs(self.EnemyWards) do
            if c_a == a_a then
              self.LastWardAttacked = {
                Time = Helper:GetTime(),
                LastAttack = Orbwalker.LastAttack,
                Object = c_a
              }
            end
          end
        end
      end
      function _ENV._Wards:_OnDeleteObj(a_a)
        for b_a, c_a in pairs(self.EnemyWards) do
          if a_a == c_a then
            table.remove(self.EnemyWards, b_a)
          end
        end
      end
      function _ENV._Wards:GetAttackableWard()
        for a_a, b_a in pairs(self.EnemyWards) do
          if Helper:GetDistance(b_a) < MyHero.TrueRange and b_a.visible and not b_a.dead then
            return b_a
          end
        end
      end
   --[[
				_Keys Class
		]]

		class '_Keys' Keys = nil

		function _Keys:__init()
			self.KEYS_KEY = 0
			self.KEYS_MENUKEY = 1
			self.AutoCarry = false
			self.MixedMode = false
			self.LastHit = false
			self.LaneClear = false
			self.AutoCarryKeys = {}
			self.MixedModeKeys = {}
			self.LastHitKeys = {}
			self.LaneClearKeys = {}
			self.LMouseDown = false
			self.AutoCarryKeyDown = false
			self.MixedModeKeyDown = false
			self.LaneClearKeyDown = false
			self.LastHitKeyDown = false
			Keys = self

			AddTickCallback(function() self:_OnTick() end)
			AddMsgCallback(function(Msg, Key) self:_OnWndMsg(Msg, Key) end)
		end

		function _Keys:_OnTick()
			self.AutoCarry = self:IsKeyEnabled(self.AutoCarryKeys)
			self.MixedMode = self:IsKeyEnabled(self.MixedModeKeys)
			self.LastHit = self:IsKeyEnabled(self.LastHitKeys)
			self.LaneClear = self:IsKeyEnabled(self.LaneClearKeys)
			self:ModeKeyPressed()
		end

		function _Keys:ModeKeyPressed()
			if self.AutoCarryKeyDown and not AutoCarryMenu.Active and not AutoCarryMenu.Toggle then
				self:EnableMode(MODE_AUTOCARRY)
			elseif self.MixedModeKeyDown and not MixedModeMenu.Active and not MixedModeMenu.Toggle then
				self:EnableMode(MODE_MIXEDMODE)
			elseif self.LaneClearKeyDown and not LaneClearMenu.Active and not LaneClearMenu.Toggle then
				self:EnableMode(MODE_LANECLEAR)
			elseif self.LastHitKeyDown and not LastHitMenu.Active and not LastHitMenu.Toggle then
				self:EnableMode(MODE_LASTHIT)
			end
		end

		function _Keys:EnableMode(Mode)
			AutoCarryMenu.Active = (Mode == MODE_AUTOCARRY and true or false)
			MixedModeMenu.Active = (Mode == MODE_MIXEDMODE and true or false)
			LaneClearMenu.Active = (Mode == MODE_LANECLEAR and true or false)
			LastHitMenu.Active = (Mode == MODE_LASTHIT and true or false)
		end

		function _Keys:_OnWndMsg(Msg, Key)
			if Msg == WM_LBUTTONDOWN then
				self.LMouseDown = true
			elseif Msg == WM_LBUTTONUP then
				self.LMouseDown = false
			elseif Msg == KEY_DOWN then
				if Key == AutoCarryMenu._param[5].key then
					self.AutoCarryKeyDown = true
				elseif Key == MixedModeMenu._param[3].key then
					self.MixedModeKeyDown = true
				elseif Key == LaneClearMenu._param[3].key then
					self.LaneClearKeyDown = true
				elseif Key == LastHitMenu._param[3].key then
					self.LastHitKeyDown = true
				end
			elseif Msg == KEY_UP then
				if Key == AutoCarryMenu._param[5].key then
					self.AutoCarryKeyDown = false
				elseif Key == MixedModeMenu._param[3].key then
					self.MixedModeKeyDown = false
				elseif Key == LaneClearMenu._param[3].key then
					self.LaneClearKeyDown = false
				elseif Key == LastHitMenu._param[3].key then
					self.LastHitKeyDown = false
				end
			end
		end

		function _Keys:IsKeyEnabled(List)
			for _, Key in pairs(List) do
				if Key.Type == self.KEYS_KEY then
					if IsKeyDown(Key.Key) then
						return true
					end
				elseif Key.Type == self.KEYS_MENUKEY then
					if Key.Menu[Key.Param] then
						return true
					end
				end
			end
			
			if List == self.AutoCarryKeys and AutoCarryMenu and AutoCarryMenu.LeftClick and self.LMouseDown then
				return true		
			end
			
			return false
		end

		function _Keys:RegisterMenuKey(Menu, Param, Mode)
			local MenuKey = _MenuKey(Menu, Param)
			self:Insert(MenuKey, Mode)
		end

		function _Keys:RegisterKey(key, Mode)
			local Key = _Key(key)
			self:Insert(Key, Mode)
		end

		function _Keys:UnregisterKey(_Key, Mode)
			for i, Key in pairs(self:GetKeyList(Mode)) do
				if Key.Key == _Key then
					table.remove(self:GetKeyList(Mode), i)
				end
			end
		end

		function _Keys:Insert(Key, Mode)
			if Mode == MODE_AUTOCARRY then
				table.insert(self.AutoCarryKeys, Key)
			elseif Mode == MODE_MIXEDMODE then
				table.insert(self.MixedModeKeys, Key)
			elseif Mode == MODE_LASTHIT then
				table.insert(self.LastHitKeys, Key)
			elseif Mode == MODE_LANECLEAR then
				table.insert(self.LaneClearKeys, Key)
			end
		end

		function _Keys:GetKeyList(Mode)
			if Mode == MODE_AUTOCARRY then
				return self.AutoCarryKeys
			elseif Mode == MODE_MIXEDMODE then
				return self.MixedModeKeys
			elseif Mode == MODE_LASTHIT then
				return self.LastHitKeys
			elseif Mode == MODE_LANECLEAR then
				return self.LaneClearKeys
			end
		end


      class("_Key")
      function _ENV._Key:__init(a_a)
        self.Key = a_a
        self.Type = Keys.KEYS_KEY
      end
      class("_MenuKey")
      function _ENV._MenuKey:__init(a_a, b_a)
        self.Menu = a_a
        self.Param = b_a
        self.Type = Keys.KEYS_MENUKEY
      end
      class("_MinionDraw")
      _ENV.MinionDraw = nil
      function _ENV._MinionDraw:__init()
        AddDrawCallback(function()
          self:_OnDraw()
        end)
      end
      function _ENV._MinionDraw:_OnDraw()
        if MinionHealthMenu.Enable then
          local a_a = MinionHealthMenu.MaxDraw
          local b_a = 1
          for c_a, d_a in ipairs(Minions.EnemyMinions.objects) do
            if a_a >= b_a and Orbwalker:CanOrbwalkTargetCustomRange(d_a, myHero.range + 500) then
              self:DoDraw(d_a)
              b_a = b_a + 1
            end
          end
          if ValidTarget(Minions.KillableMinion) then
          elseif ValidTarget(Minions.AlmostKillable) then
          end
        end
      end
      function _ENV._MinionDraw:DoDraw(a_a)
        local b_a = GetUnitHPBarPos(a_a)
        local c_a = Minions:MyDamage(a_a)
        local d_a = math.ceil(a_a.maxHealth / c_a)
        local _aa = math.ceil(a_a.health / c_a)
        if not (_aa < 9) or not _aa then
          _aa = 8
        end
        local aaa = c_a / (a_a.maxHealth / 62)
        local baa = 0
        for i = 1, _aa do
          baa = baa + aaa
          if baa < 62 then
            self:DrawTickerBar(b_a.x - 32 + baa, b_a.y, 2, 4, ARGB(255, 0, 0, 0))
          end
        end
      end
      function _ENV._MinionDraw:DrawTickerBar(a_a, b_a, c_a, d_a, _aa)
        local aaa = {}
        aaa[1] = D3DXVECTOR2(math.floor(a_a), math.floor(b_a))
        aaa[2] = D3DXVECTOR2(math.floor(a_a + c_a), math.floor(b_a))
        DrawLines2(aaa, math.floor(d_a), _aa)
      end
      function _ENV._MinionDraw:DrawOutline(a_a, b_a)
        local c_a = GetUnitHPBarPos(a_a)
        local d_a = b_a and ARGB(255, 0, 255, 0) or ARGB(255, 255, 0, 0)
        self:DrawTickerBar(c_a.x - 32, c_a.y - 3, 64, 1, d_a)
        self:DrawTickerBar(c_a.x - 32, c_a.y + 2, 64, 1, d_a)
        self:DrawTickerBar(c_a.x - 32, c_a.y, 1, 5, d_a)
        self:DrawTickerBar(c_a.x - 32 + 63, c_a.y, 1, 5, d_a)
      end
      function _ENV._MinionDraw:DrawKillable(a_a)
        local b_a = GetUnitHPBarPos(a_a)
        b_a.x = b_a.x - 32
        DrawLine(b_a.x, b_a.y - 1, b_a.x + 62, b_a.y - 1, 3, ARGB(255, 0, 255, 0))
      end
      class("_MenuManager")
      _ENV.MenuManager = nil
      function _ENV._MenuManager:__init()
        self.AutoCarry = false
        self.MixedMode = false
        self.LastHit = false
        self.LaneClear = false
        self.LaneFreeze = false
        self.LastSaveTick = 0
        self.LoadedData = {}
        AddTickCallback(function()
          self:OnTick()
        end)
        AddMsgCallback(function(a_a, b_a)
          self:OnWndMsg(a_a, b_a)
        end)
        MenuManager = self
        ModesMenu = scriptConfig("Sida's Auto Carry: Setup", "sidasacsetup")
        ModesMenu:addSubMenu("Auto Carry Mode", "sidasacautocarrysub")
        ModesMenu:addSubMenu("Last Hit Mode", "sidasaclasthitsub")
        ModesMenu:addSubMenu("Mixed Mode", "sidasacmixedmodesub")
        ModesMenu:addSubMenu("Lane Clear Mode", "sidasaclaneclearsub")
        ModesMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        ModesMenu:addParam("TargetLock", "Target Lock", SCRIPT_PARAM_ONKEYDOWN, false, string.byte("G"))
        AutoCarryMenu = ModesMenu.sidasacautocarrysub
        LastHitMenu = ModesMenu.sidasaclasthitsub
        MixedModeMenu = ModesMenu.sidasacmixedmodesub
        LaneClearMenu = ModesMenu.sidasaclaneclearsub
        ConfigurationMenu = scriptConfig("Sida's Auto Carry: Configuration", "sidasacconfigsub")
        ConfigurationMenu:addSubMenu("Drawing", "sidasacdrawingsub")
        ConfigurationMenu:addSubMenu("Enemy AA Range Circles", "sidasacenemyrangesub")
        ConfigurationMenu:addSubMenu("Minion Drawing", "sidasacminionhealthsub")
        ConfigurationMenu:addSubMenu("Melee Config", "sidasacmeleesub")
        ConfigurationMenu:addSubMenu("Advanced", "sidasacadvancedsub")
        ConfigurationMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        ConfigurationMenu:addParam("FocusedTarget", "Focus Selected Target", SCRIPT_PARAM_LIST, 1, {
          "None",
          "When In Range",
          "Absolute Target Lock"
        })
        ConfigurationMenu:addParam("SupportMode", "Support Mode", SCRIPT_PARAM_ONOFF, false)
        ConfigurationMenu:addParam("ToggleRightClickDisable", "Disable Toggle Mode On Right Click", SCRIPT_PARAM_ONOFF, true)
        ConfigurationMenu:addParam("HoldZone", "Mouse Over Hero To Stop Move", SCRIPT_PARAM_ONOFF, false)
        ConfigurationMenu:addParam("AttackStructures", "Attack Selected Buildings", SCRIPT_PARAM_ONOFF, true)
        DrawingMenu = ConfigurationMenu.sidasacdrawingsub
        EnemyRangeMenu = ConfigurationMenu.sidasacenemyrangesub
        MinionHealthMenu = ConfigurationMenu.sidasacminionhealthsub
        MeleeMenu = ConfigurationMenu.sidasacmeleesub
        UpdateMenu = ConfigurationMenu.sidasacupdatesub
        AdvancedMenu = ConfigurationMenu.sidasacadvancedsub
        if ConfigurationMenu.SupportMode then
          ConfigurationMenu.SupportMode = false
        end
        if 0 < #Skills.SkillsList then
          SkillsMenu = scriptConfig("Sida's Auto Carry: Skills", "sidasacskills")
          for a_a, b_a in pairs(Skills.SkillsList) do
            SkillsMenu:addSubMenu(b_a.DisplayName, b_a.RawName)
            SkillsMenu[b_a.RawName]:addParam("AutoCarry", "Use In Auto Carry", SCRIPT_PARAM_ONOFF, false)
            SkillsMenu[b_a.RawName]:addParam("MixedMode", "Use In Mixed Mode", SCRIPT_PARAM_ONOFF, false)
            SkillsMenu[b_a.RawName]:addParam("LaneClear", "Use In Lane Clear", SCRIPT_PARAM_ONOFF, false)
            SkillsMenu[b_a.RawName]:addParam("Killsteal", "Killsteal", SCRIPT_PARAM_ONOFF, false)
            SkillsMenu[b_a.RawName]:addParam("LaneClearFarm", "Lane Clear Farm/Push", SCRIPT_PARAM_ONOFF, false)
            SkillsMenu[b_a.RawName]:addParam("Jungle", "Jungle Clear", SCRIPT_PARAM_ONOFF, false)
          end
          SkillsMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
          SkillsMenu:addParam("SkillFarm", "Enable/Disable Skill Farm", SCRIPT_PARAM_ONKEYTOGGLE, true, string.byte("H"))
          SkillsMenu:addParam("FarmMinMana", "Skill Farm Min Mana", SCRIPT_PARAM_SLICE, 30, 0, 100, 0)
        end
        FarmMenu = scriptConfig("Sida's Auto Carry: Farming", "sidasfarming")
        FarmMenu:addSubMenu("Masteries", "sidasacsubmasteries")
        FarmMenu:addSubMenu("Damage Prediction Settings", "sidasacpredictionfarm")
        FarmMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        FarmMenu:addParam("LaneFreeze", "Lane Freeze (Default F1)", SCRIPT_PARAM_ONKEYTOGGLE, false, 112)
        MasteryMenu = FarmMenu.sidasacsubmasteries
        DamagePredictionMenu = FarmMenu.sidasacpredictionfarm
        DamagePredictionMenu:addParam("laneClearType", "Lane Clear Method", SCRIPT_PARAM_LIST, 1, {
          "Default",
          "Method 2",
          "Method 3"
        })
        MasteryMenu:addParam("Butcher", "Butcher", SCRIPT_PARAM_ONOFF, false)
        MasteryMenu:addParam("ArcaneBlade", "Arcane Blade", SCRIPT_PARAM_ONOFF, false)
        MasteryMenu:addParam("Havoc", "Havoc", SCRIPT_PARAM_ONOFF, false)
        MasteryMenu:addParam("DoubleEdgedSword", "Double-Edged Sword", SCRIPT_PARAM_ONOFF, false)
        MasteryMenu:addParam("DevastatingStrikes", "Devastating Strike", SCRIPT_PARAM_SLICE, 0, 0, 3, 0)
        MasteryMenu.Butcher = self:LoadChampData("Butcher") or false
        MasteryMenu.ArcaneBlade = self:LoadChampData("ArcaneBlade") or false
        MasteryMenu.Havoc = self:LoadChampData("Havoc") or false
        MasteryMenu.DoubleEdgedSword = self:LoadChampData("DoubleEdgedSword") or false
        MasteryMenu.DevastatingStrikes = self:LoadChampData("DevastatingStrikes") or 0
        AutoCarryMenu:addParam("sep", "-- Settings--", SCRIPT_PARAM_INFO, "")
        AutoCarryMenu:addParam("LeftClick", "Left Click Mode", SCRIPT_PARAM_ONOFF, false)
        AutoCarryMenu:addParam("Toggle", "Toggle mode (requires reload)", SCRIPT_PARAM_ONOFF, false)
        AutoCarryMenu:addParam("Active", "Hotkey", (not AutoCarryMenu.Toggle or not SCRIPT_PARAM_ONKEYTOGGLE) and SCRIPT_PARAM_ONKEYDOWN, false, 32)
        AutoCarryMenu:addTS(Crosshair.Attack_Crosshair)
        Keys:RegisterMenuKey(AutoCarryMenu, "Active", MODE_AUTOCARRY)
        AutoCarryMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        AutoCarryMenu:addParam("sep", "-- Items --", SCRIPT_PARAM_INFO, "")
        for a_a, b_a in pairs(Items.ItemList) do
          AutoCarryMenu:addParam(b_a.RawName .. "AutoCarry", "Use " .. b_a.Name, SCRIPT_PARAM_ONOFF, true)
        end
        AutoCarryMenu:addParam("botrkSave", "Save BotRK for max heal", SCRIPT_PARAM_ONOFF, true)
        AutoCarryMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        AutoCarryMenu:addParam("sep", "-- Moving/Attacking --", SCRIPT_PARAM_INFO, "")
        AutoCarryMenu:addParam("Movement", "Movement Enabled", SCRIPT_PARAM_ONOFF, true)
        AutoCarryMenu:addParam("Attacks", "Attacks Enabled", SCRIPT_PARAM_ONOFF, true)
        LastHitMenu:addParam("sep", "-- Settings--", SCRIPT_PARAM_INFO, "")
        LastHitMenu:addParam("Toggle", "Toggle mode (requires reload)", SCRIPT_PARAM_ONOFF, false)
        LastHitMenu:addParam("Active", "Hotkey", (not LastHitMenu.Toggle or not SCRIPT_PARAM_ONKEYTOGGLE) and SCRIPT_PARAM_ONKEYDOWN, false, string.byte("X"))
        LastHitMenu:addParam("AntiFarm", "Anti-farm/harass (attack back)", SCRIPT_PARAM_ONOFF, false)
        LastHitMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        LastHitMenu:addParam("sep", "-- Moving/Attacking --", SCRIPT_PARAM_INFO, "")
        LastHitMenu:addParam("Movement", "Movement Enabled", SCRIPT_PARAM_ONOFF, true)
        LastHitMenu:addParam("Attacks", "Attacks Enabled", SCRIPT_PARAM_ONOFF, true)
        Keys:RegisterMenuKey(LastHitMenu, "Active", MODE_LASTHIT)
        MixedModeMenu:addParam("sep", "-- Settings--", SCRIPT_PARAM_INFO, "")
        MixedModeMenu:addParam("Toggle", "Toggle mode (requires reload)", SCRIPT_PARAM_ONOFF, false)
        MixedModeMenu:addParam("Active", "Hotkey", (not MixedModeMenu.Toggle or not SCRIPT_PARAM_ONKEYTOGGLE) and SCRIPT_PARAM_ONKEYDOWN, false, string.byte("C"))
        MixedModeMenu:addParam("MinionPriority", "Prioritise Last Hit Over Harass", SCRIPT_PARAM_ONOFF, true)
        Keys:RegisterMenuKey(MixedModeMenu, "Active", MODE_MIXEDMODE)
        MixedModeMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        MixedModeMenu:addParam("sep", "-- Items (Against Champions Only) --", SCRIPT_PARAM_INFO, "")
        for a_a, b_a in pairs(Items.ItemList) do
          MixedModeMenu:addParam(b_a.RawName .. "MixedMode", "Use " .. b_a.Name, SCRIPT_PARAM_ONOFF, false)
        end
        MixedModeMenu:addParam("botrkSave", "Save BotRK for max heal", SCRIPT_PARAM_ONOFF, true)
        MixedModeMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        MixedModeMenu:addParam("sep", "-- Moving/Attacking --", SCRIPT_PARAM_INFO, "")
        MixedModeMenu:addParam("Movement", "Movement Enabled", SCRIPT_PARAM_ONOFF, true)
        MixedModeMenu:addParam("Attacks", "Attacks Enabled", SCRIPT_PARAM_ONOFF, true)
        LaneClearMenu:addParam("sep", "-- Settings--", SCRIPT_PARAM_INFO, "")
        LaneClearMenu:addParam("Toggle", "Toggle mode (requires reload)", SCRIPT_PARAM_ONOFF, false)
        LaneClearMenu:addParam("Active", "Hotkey", (not LaneClearMenu.Toggle or not SCRIPT_PARAM_ONKEYTOGGLE) and SCRIPT_PARAM_ONKEYDOWN, false, string.byte("V"))
        LaneClearMenu:addParam("AttackEnemies", "Attack Enemies", SCRIPT_PARAM_ONOFF, true)
        LaneClearMenu:addParam("MinionPriority", "Prioritise Last Hit Over Harass", SCRIPT_PARAM_ONOFF, true)
        Keys:RegisterMenuKey(LaneClearMenu, "Active", MODE_LANECLEAR)
        LaneClearMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        LaneClearMenu:addParam("sep", "-- Items (Against Champions Only) --", SCRIPT_PARAM_INFO, "")
        for a_a, b_a in pairs(Items.ItemList) do
          LaneClearMenu:addParam(b_a.RawName .. "LaneClear", "Use " .. b_a.Name, SCRIPT_PARAM_ONOFF, false)
        end
        LaneClearMenu:addParam("botrkSave", "Save BotRK for max heal", SCRIPT_PARAM_ONOFF, true)
        LaneClearMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        LaneClearMenu:addParam("sep", "-- Moving/Attacking --", SCRIPT_PARAM_INFO, "")
        LaneClearMenu:addParam("Movement", "Movement Enabled", SCRIPT_PARAM_ONOFF, true)
        LaneClearMenu:addParam("Attacks", "Attacks Enabled", SCRIPT_PARAM_ONOFF, true)
        DrawingMenu:addParam("RangeCircle", "Champion Range Circle", SCRIPT_PARAM_ONOFF, true)
        DrawingMenu:addParam("RangeCircleColour", "Colour", SCRIPT_PARAM_COLOR, {
          255,
          0,
          189,
          22
        })
        DrawingMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        DrawingMenu:addParam("TargetCircle", "Circle Around Target", SCRIPT_PARAM_ONOFF, true)
        DrawingMenu:addParam("TargetCircleColour", "Colour", SCRIPT_PARAM_COLOR, {
          255,
          0,
          112,
          95
        })
        DrawingMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        DrawingMenu:addParam("MeleeSticky", "Stick To Target Range (Melee Only)", SCRIPT_PARAM_ONOFF, true)
        DrawingMenu:addParam("MeleeStickyColour", "Stick To Target Colour", SCRIPT_PARAM_COLOR, {
          183,
          0,
          26,
          173
        })
        DrawingMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        DrawingMenu:addParam("TargetLock", "Draw Target Lock Circle", SCRIPT_PARAM_ONOFF, true)
        DrawingMenu:addParam("TargetLockColour", "Target Lock Colour", SCRIPT_PARAM_COLOR, {
          255,
          173,
          0,
          0
        })
        DrawingMenu:addParam("TargetLockText", "Target Lock Reminder Text", SCRIPT_PARAM_ONOFF, true)
        DrawingMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        DrawingMenu:addParam("LowFPSCir", "Use Low FPS Circles", SCRIPT_PARAM_ONOFF, true)
        DrawingMenu:addParam("PermaShow", "Show PermaShow box", SCRIPT_PARAM_ONOFF, true)
        MeleeMenu:addParam("MeleeStickyRange", "Stick To Target Range (Melee Only)", SCRIPT_PARAM_SLICE, 0, 0, 300, 0)
        AdvancedMenu:addParam("FarmOffsetType", "Last Hit Adjustment:", SCRIPT_PARAM_LIST, 1, {
          "None",
          "  Last Hit Earlier  ",
          "  Last Hit Later  "
        })
        AdvancedMenu:addParam("FarmOffsetAmount", "Adjustment Amount:", SCRIPT_PARAM_SLICE, 0, 0, 150, 0)
        AdvancedMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        AdvancedMenu:addParam("WindUpType", "Animation Cancel Adjustment:", SCRIPT_PARAM_LIST, 1, {
          "None",
          "  Cancel Earlier  ",
          "  Cancel Later  "
        })
        AdvancedMenu:addParam("WindUpAmount", "Adjustment Amount:", SCRIPT_PARAM_SLICE, 0, 0, 150, 0)
        AdvancedMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        AdvancedMenu:addParam("MouseOverFix", "Mouse Over Hero AA Cancel Fix:", SCRIPT_PARAM_SLICE, 0, 0, 300, 0)
        AdvancedMenu.FarmOffsetType = self:LoadChampData("FarmOffsetType") or 1
        AdvancedMenu.FarmOffsetAmount = self:LoadChampData("FarmOffsetAmount") or 0
        if 0 > AdvancedMenu.FarmOffsetAmount then
          AdvancedMenu.FarmOffsetAmount = AdvancedMenu.FarmOffsetAmount * -1
        end
        AdvancedMenu.WindUpType = self:LoadChampData("WindUpType") or 1
        AdvancedMenu.WindUpAmount = self:LoadChampData("WindUpAmount") or 0
        if 0 > AdvancedMenu.WindUpAmount then
          AdvancedMenu.WindUpAmount = AdvancedMenu.WindUpAmount * -1
        end
        EnemyRangeMenu:addParam("sep", "By Role:", SCRIPT_PARAM_INFO, "")
        EnemyRangeMenu:addParam("Role" .. ROLE_AD_CARRY, "    Draw ADC", SCRIPT_PARAM_ONOFF, true)
        EnemyRangeMenu:addParam("Role" .. ROLE_AP, "    Draw AP Carry", SCRIPT_PARAM_ONOFF, true)
        EnemyRangeMenu:addParam("Role" .. ROLE_SUPPORT, "    Draw Support", SCRIPT_PARAM_ONOFF, true)
        EnemyRangeMenu:addParam("Role" .. ROLE_BRUISER, "    Draw Bruiser", SCRIPT_PARAM_ONOFF, true)
        EnemyRangeMenu:addParam("Role" .. ROLE_TANK, "    Draw Tank", SCRIPT_PARAM_ONOFF, true)
        EnemyRangeMenu:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        EnemyRangeMenu:addParam("sep", "By Champion:", SCRIPT_PARAM_INFO, "")
        for a_a, b_a in pairs(GetEnemyHeroes()) do
          EnemyRangeMenu:addParam(b_a.charName, "    Draw " .. b_a.charName, SCRIPT_PARAM_ONOFF, false)
        end
        MinionHealthMenu:addParam("Enable", "Modify Minion Health Bars", SCRIPT_PARAM_ONOFF, true)
        MinionHealthMenu:addParam("MaxDraw", "Maximum Health Bars To Modify", SCRIPT_PARAM_SLICE, 10, 1, 30, 0)
        MinionHealthMenu:addParam("MinionArrows", "Draw Last Hit Arrows", SCRIPT_PARAM_ONOFF, true)
        MinionHealthMenu:addParam("MinionMarker", "Always Draw Last Hit Arrows", SCRIPT_PARAM_ONOFF, false)
        self:DisableAllModes()
      end
      function _ENV._MenuManager:OnTick()
        if AutoCarryMenu.Active ~= self.AutoCarry and not self.AutoCarry then
          self:SetToggles(true, false, false, false)
        elseif MixedModeMenu.Active ~= self.MixedMode and not self.MixedMode then
          self:SetToggles(false, true, false, false)
        elseif LastHitMenu.Active ~= self.LastHit and not self.LastHit then
          self:SetToggles(false, false, true, false)
        elseif LaneClearMenu.Active ~= self.LaneClear and not self.LaneClear then
          self:SetToggles(false, false, false, true)
        end
        local a_a = not Streaming.StreamEnabled and DrawingMenu.PermaShow
        CustomPermaShow("              Sida's Auto Carry: Reborn", "", a_a, nil)
        CustomPermaShow("Auto Carry", "      Active", AutoCarryMenu.Active and a_a, 1426521024)
        CustomPermaShow("Last Hit", "      Active", LastHitMenu.Active and a_a, 1426521024)
        CustomPermaShow("Mixed Mode", "      Active", MixedModeMenu.Active and a_a, 1426521024)
        CustomPermaShow("Lane Clear", "      Active", LaneClearMenu.Active and a_a, 1426521024)
        local b_a = not Keys.AutoCarry and not Keys.MixedMode and not Keys.LastHit and not Keys.LaneClear and a_a
        CustomPermaShow("No mode active", "      ", b_a)
        CustomPermaShow("Lane Freeze (F1)", "      Active", FarmMenu.LaneFreeze and a_a, 1426521024)
        CustomPermaShow("Support Mode", "      Active", ConfigurationMenu.SupportMode and a_a, 1426521024)
        if SkillsMenu then
          CustomPermaShow("Skill Farm", "      Active", SkillsMenu.SkillFarm and a_a, 1426521024)
        end
        CustomPermaShow("TARGET LOCK", "      Active", ModesMenu.TargetLock and a_a, 1426521024)
        if not self.FocusModeSelected then
          self.FocusModeSelected = ConfigurationMenu.FocusedTarget
          FocusMessageDone = true
        elseif ConfigurationMenu.FocusedTarget == 3 and not FocusMessageDone then
          PrintSystemMessage("Warning: Absolute Target Lock will not attack anything except your target, including minions, jungle, other enemies etc.")
          FocusMessageDone = true
        elseif ConfigurationMenu.FocusedTarget ~= 3 and FocusMessageDone then
          FocusMessageDone = false
        end
        self:SaveConfig()
      end
      function _ENV._MenuManager:OnWndMsg(a_a, b_a)
        if a_a == WM_RBUTTONDOWN then
          local c_a = self:GetActiveMenu()
          if c_a and c_a.Toggle and ConfigurationMenu.ToggleRightClickDisable then
            self:DisableAllModes()
          end
        end
      end
      function _ENV._MenuManager:SaveConfig()
        if AdvancedMenu.FarmOffsetType == 2 then
          FarmOffset = AdvancedMenu.FarmOffsetAmount * -1
        elseif AdvancedMenu.FarmOffsetType == 3 then
          FarmOffset = AdvancedMenu.FarmOffsetAmount
        else
          FarmOffset = 0
        end
        self:SaveChampData("FarmOffsetAmount", FarmOffset)
        self:SaveChampData("FarmOffsetType", AdvancedMenu.FarmOffsetType)
        if AdvancedMenu.WindUpType == 2 then
          WindOffset = AdvancedMenu.WindUpAmount * -1
        elseif AdvancedMenu.WindUpType == 3 then
          WindOffset = AdvancedMenu.WindUpAmount
        else
          WindOffset = 0
        end
        self:SaveChampData("WindUpAmount", WindOffset)
        self:SaveChampData("WindUpType", AdvancedMenu.WindUpType)
        self:SaveChampData("Butcher", MasteryMenu.Butcher)
        self:SaveChampData("ArcaneBlade", MasteryMenu.ArcaneBlade)
        self:SaveChampData("Havoc", MasteryMenu.Havoc)
        self:SaveChampData("DoubleEdgedSword", MasteryMenu.DoubleEdgedSword)
        self:SaveChampData("DevastatingStrikes", MasteryMenu.DevastatingStrikes)
      end
      function _ENV._MenuManager:SaveChampData(a_a, b_a)
        local c_a = GetSave("SidasAutoCarry")[a_a]
        if not c_a then
          GetSave("SidasAutoCarry")[a_a] = {}
        end
        GetSave("SidasAutoCarry")[a_a][myHero.charName] = b_a
      end
      function _ENV._MenuManager:LoadChampData(a_a)
        if not self.LoadedData[a_a] then
          self.LoadedData[a_a] = GetSave("SidasAutoCarry")[a_a] and GetSave("SidasAutoCarry")[a_a][myHero.charName]
        end
        return self.LoadedData[a_a]
      end
      function _ENV._MenuManager:GetFarmOffset()
        if AdvancedMenu.FarmOffsetType == 2 then
          FarmOffset = AdvancedMenu.FarmOffsetAmount * -1
        elseif AdvancedMenu.FarmOffsetType == 3 then
          FarmOffset = AdvancedMenu.FarmOffsetAmount
        else
          FarmOffset = 0
        end
        return FarmOffset
      end
      function _ENV._MenuManager:GetWindUpOffset()
        if AdvancedMenu.WindUpType == 2 then
          WindOffset = AdvancedMenu.WindUpAmount * -1
        elseif AdvancedMenu.WindUpType == 3 then
          WindOffset = AdvancedMenu.WindUpAmount
        else
          WindOffset = 0
        end
        return WindOffset
      end
      function _ENV._MenuManager:SetToggles(a_a, b_a, c_a, d_a)
        AutoCarryMenu.Active, self.AutoCarry = a_a, a_a
        MixedModeMenu.Active, self.MixedMode = b_a, b_a
        LastHitMenu.Active, self.LastHit = c_a, c_a
        LaneClearMenu.Active, self.LaneClear = d_a, d_a
      end
      function _ENV._MenuManager:DisableAllModes()
        AutoCarryMenu.Active = false
        MixedModeMenu.Active = false
        LastHitMenu.Active = false
        LaneClearMenu.Active = false
      end
      function _ENV._MenuManager:GetActiveMenu()
        if AutoCarryMenu.Active then
          return AutoCarryMenu
        elseif MixedModeMenu.Active then
          return MixedModeMenu
        elseif LastHitMenu.Active then
          return LastHitMenu
        elseif LaneClearMenu.Active then
          return LaneClearMenu
        end
      end
      class("_Plugins")
      _ENV.Plugins = nil
      function _ENV._Plugins:__init()
        self.Plugins = {}
        self.RegisteredBonusLastHitDamage = {}
        self.RegisteredPreAttack = {}
        Plugins = self
      end
      function _ENV._Plugins:RegisterPlugin(a_a, b_a)
        if a_a.OnTick then
          AddTickCallback(function()
            a_a:OnTick()
          end)
        end
        if a_a.OnDraw then
          AddDrawCallback(function()
            a_a:OnDraw()
          end)
        end
        if a_a.OnCreateObj then
          AddCreateObjCallback(function(c_a)
            a_a:OnCreateObj(c_a)
          end)
        end
        if a_a.OnDeleteObj then
          AddDeleteObjCallback(function(c_a)
            a_a:OnDeleteObj(c_a)
          end)
        end
        if a_a.OnLoad then
          a_a:OnLoad()
        end
        if a_a.OnUnload then
          AddUnloadCallback(function()
            OnUnload()
          end)
        end
        if a_a.OnWndMsg then
          AddMsgCallback(function(c_a, d_a)
            a_a:OnWndMsg(c_a, d_a)
          end)
        end
        if a_a.OnProcessSpell then
          AddProcessSpellCallback(function(c_a, d_a)
            a_a:OnProcessSpell(c_a, d_a)
          end)
        end
        if a_a.OnSendChat then
          AddChatCallback(function(c_a)
            a_a:OnSendChat(c_a)
          end)
        end
        if a_a.OnBugsplat then
          AddBugsplatCallback(function()
            a_a:OnBugsplat()
          end)
        end
        if a_a.OnAnimation then
          AddAnimationCallback(function(c_a, d_a)
            a_a:OnAnimation(c_a, d_a)
          end)
        end
        if a_a.OnSendPacket then
          AddSendPacketCallback(function(c_a)
            a_a:OnSendPacket(c_a)
          end)
        end
        if a_a.OnRecvPacket then
          AddRecvPacketCallback(function(c_a)
            a_a:OnRecvPacket(c_a)
          end)
        end
        if b_a then
          self.Plugins[b_a] = scriptConfig("Sida's Auto Carry Plugin: " .. b_a, "sidasacautocarryplugin" .. b_a)
          return self.Plugins[b_a]
        end
      end
      function _ENV._Plugins:RegisterBonusLastHitDamage(a_a)
        table.insert(self.RegisteredBonusLastHitDamage, a_a)
      end
      function _ENV._Plugins:RegisterPreAttack(a_a)
        table.insert(self.RegisteredPreAttack, a_a)
      end
      function _ENV._Plugins:RegisterOnAttacked(a_a)
        RegisterOnAttacked(a_a)
      end
      function _ENV._Plugins:GetProdiction(a_a, b_a, c_a, d_a, _aa, aaa, baa)
        return {}
      end
      class("_Drawing")
      function _ENV._Drawing:__init()
        self.LastTargetLockCircle = 400
        self.LastTargetLockCircleUpdate = Helper:GetTime()
        self.EnemyRoles = {}
        for a_a, b_a in pairs(GetEnemyHeroes()) do
          local c_a = Data:GetChampionRole(b_a.charName)
          if c_a then
            self.EnemyRoles[b_a.charName] = c_a
          end
        end
        AddDrawCallback(function()
          self:_OnDraw()
        end)
      end
      function _ENV._Drawing:_OnDraw()
        if Streaming.StreamEnabled then
          return
        end
        if DrawingMenu.RangeCircle then
          Helper:DrawCircleObject(myHero, MyHero.TrueRange + 55, Helper:ArgbFromMenu(DrawingMenu.RangeCircleColour))
        end
        if DrawingMenu.TargetCircle and Crosshair.Target and not Crosshair.TargetLock then
          Helper:DrawCircleObject(Crosshair.Target, 100, Helper:ArgbFromMenu(DrawingMenu.TargetCircleColour), 6)
        end
        if DrawingMenu.MeleeSticky and MeleeMenu.MeleeStickyRange > 0 and myHero.range < 300 then
          Helper:DrawCircleObject(myHero, MeleeMenu.MeleeStickyRange, Helper:ArgbFromMenu(DrawingMenu.MeleeStickyColour))
        end
        if MinionHealthMenu.MinionArrows then
          if Minions.KillableMinion then
            self:DrawWhiteMinionSprite(Minions.KillableMinion)
          elseif Minions.AlmostKillable then
            self:DrawOrangeMinionSprite(Minions.AlmostKillable)
          end
        end
        if DrawingMenu.TargetLock and Crosshair.TargetLock then
          Helper:DrawCircleObject(Crosshair.TargetLock, 100, Helper:ArgbFromMenu(DrawingMenu.TargetCircleColour), 6)
          Helper:DrawCircleObject(Crosshair.TargetLock, self.LastTargetLockCircle, Helper:ArgbFromMenu(DrawingMenu.TargetLockColour), 5)
          if Helper:GetTime() > self.LastTargetLockCircleUpdate + 30 then
            self.LastTargetLockCircle = self.LastTargetLockCircle < 400 and self.LastTargetLockCircle + 20 or 50
            self.LastTargetLockCircleUpdate = Helper:GetTime()
          end
        end
        if DrawingMenu.TargetLockText and Crosshair.TargetLock then
          DrawText("Target Lock: " .. Crosshair.TargetLock.charName, 30, WINDOW_W / 2 - 100, WINDOW_H / 2, 4294901760)
        end
        for a_a, b_a in pairs(GetEnemyHeroes()) do
          if Orbwalker:CanOrbwalkTargetCustomRange(b_a, 1000) then
            local c_a = self.EnemyRoles[b_a.charName]
            if c_a and EnemyRangeMenu["Role" .. c_a] or EnemyRangeMenu[b_a.charName] then
              local d_a = b_a.range + Data:GetGameplayCollisionRadius(b_a.charName) + Orbwalker:GetScalingRange(b_a)
              if d_a >= GetDistance(b_a) then
                Helper:DrawCircleObject(b_a, d_a, ARGB(255, 255, 0, 0), 4)
              else
                Helper:DrawCircleObject(b_a, d_a, ARGB(255, 0, 255, 0), 1)
              end
            end
          end
        end
      end
      function _ENV._Drawing:DrawMinionHealthSprite(a_a, b_a)
        if ValidTarget(a_a) then
          local c_a = GetUnitHPBarPos(a_a)
          if c_a and c_a.x and c_a.y then
            b_a:Draw(c_a.x - 59, c_a.y - 16, 255)
          end
        end
      end
      function _ENV._Drawing:DrawGreenMinionSprite(a_a)
        if not self.GreenSprite then
          self.GreenSprite = createSprite(SPRITE_PATH .. "SidasAutoCarry\\Minion_Green.png")
        end
        self:DrawMinionHealthSprite(a_a, self.GreenSprite)
      end
      function _ENV._Drawing:DrawRedMinionSprite(a_a)
        if not self.RedSprite then
          self.RedSprite = createSprite(SPRITE_PATH .. "SidasAutoCarry\\Minion_Red.png")
        end
        self:DrawMinionHealthSprite(a_a, self.RedSprite)
      end
      function _ENV._Drawing:DrawOrangeMinionSprite(a_a)
        if not self.OrangeSprite then
          self.OrangeSprite = createSprite(SPRITE_PATH .. "SidasAutoCarry\\Minion_Orange.png")
        end
        self:DrawMinionHealthSprite(a_a, self.OrangeSprite)
      end
      function _ENV._Drawing:DrawWhiteMinionSprite(a_a)
        if not self.WhiteSprite then
          self.WhiteSprite = createSprite(SPRITE_PATH .. "SidasAutoCarry\\Minion_White.png")
        end
        self:DrawMinionHealthSprite(a_a, self.WhiteSprite)
      end
      function _ENV._Drawing:DrawPinkMinionSprite(a_a)
        if not self.PinkSprite then
          self.PinkSprite = createSprite(SPRITE_PATH .. "SidasAutoCarry\\Minion_Pink.png")
        end
        self:DrawMinionHealthSprite(a_a, self.PinkSprite)
      end
      function _ENV._Drawing:DrawBlackMinionSprite(a_a)
        if not self.BlackSprite then
          self.BlackSprite = createSprite(SPRITE_PATH .. "SidasAutoCarry\\Minion_Black.png")
        end
        self:DrawMinionHealthSprite(a_a, self.BlackSprite)
      end
      function _ENV._Drawing:DrawGreyMinionSprite(a_a)
        if not self.GreySprite then
          self.GreySprite = createSprite(SPRITE_PATH .. "SidasAutoCarry\\Minion_Grey.png")
        end
        self:DrawMinionHealthSprite(a_a, self.GreySprite)
      end
      class("_Data")
      _ENV.Data = nil
      function _ENV._Data:__init()
        self.ResetSpells = {}
        self.SpellAttacks = {}
        self.NoneAttacks = {}
        self.ChampionData = {}
        self.MinionData = {}
        self.JungleData = {}
        self.ItemData = {}
        self.Skills = {}
        self.EnemyHitBoxes = {}
        self.ImmuneEnemies = {}
        self.WardData = {}
        self.ChannelledSpells = {}
        self.GainBuffCallbacks = {}
        self.LoseBuffCallbacks = {}
        Data = self
        self:__GenerateNoneAttacks()
        self:__GenerateSpellAttacks()
        self:__GenerateResetSpells()
        self:_GenerateMinionData()
        self:_GenerateJungleData()
        self:_GenerateItemData()
        self:__GenerateChampionData()
        self:__GenerateSkillData()
        self:_GenerateChannelledSpells()
        Data:_GenerateWardData()
        if GetGameTimer() < self:GetHitBoxLastSavedTime() then
          self:GenerateHitBoxData()
        else
          self:LoadHitBoxData()
        end
      end
      function _ENV._Data:_OnGainBuff(a_a, b_a)
        for c_a, d_a in pairs(self.GainBuffCallbacks) do
          d_a(a_a, b_a)
        end
      end
      function _ENV._Data:_OnLoseBuff(a_a, b_a)
        for c_a, d_a in pairs(self.LoseBuffCallbacks) do
          d_a(a_a, b_a)
        end
      end
      function _ENV._Data:bind(a_a, b_a)
        if a_a == "OnGainBuff" then
          table.insert(self.GainBuffCallbacks, b_a)
        elseif a_a == "OnLoseBuff" then
          table.insert(self.LoseBuffCallbacks, b_a)
        end
      end
      function _ENV._Data:_GenerateChannelledSpells()
        self:AddChannelledSpell("MissFortune", _R, "missfortunebulletsound")
        self:AddChannelledSpell("Nunu", _R, "AbsoluteZero")
        self:AddChannelledSpell("Katarina", _R, "katarinarsound")
        self:AddChannelledSpell("Janna", _R, "ReapTheWhirlwind")
        self:AddChannelledSpell("Pantheon", _E, "pantheonesound")
        self:AddChannelledSpell("MasterYi", _W, "Meditate")
        self:AddChannelledSpell("FiddleSticks", _W, "fearmonger_marker")
        self:AddChannelledSpell("Malzahar", _R, "alzaharnethergraspsound")
        self:AddChannelledSpell("Galio", _R, "GalioIdolOfDurand")
      end
      function _ENV._Data:__GenerateResetSpells()
        self:AddResetSpell("Powerfist")
        self:AddResetSpell("DariusNoxianTacticsONH")
        self:AddResetSpell("Takedown")
        self:AddResetSpell("Ricochet")
        self:AddResetSpell("VayneTumble")
        self:AddResetSpell("JaxEmpowerTwo")
        self:AddResetSpell("MordekaiserMaceOfSpades")
        self:AddResetSpell("SiphoningStrikeNew")
        self:AddResetSpell("RengarQ")
        self:AddResetSpell("MonkeyKingDoubleAttack")
        self:AddResetSpell("YorickSpectral")
        self:AddResetSpell("ViE")
        self:AddResetSpell("GarenSlash3")
        self:AddResetSpell("HecarimRamp")
        self:AddResetSpell("XenZhaoComboTarget")
        self:AddResetSpell("LeonaShieldOfDaybreak")
        self:AddResetSpell("ShyvanaDoubleAttack")
        self:AddResetSpell("shyvanadoubleattackdragon")
        self:AddResetSpell("TalonNoxianDiplomacy")
        self:AddResetSpell("TrundleTrollSmash")
        self:AddResetSpell("VolibearQ")
        self:AddResetSpell("PoppyDevastatingBlow")
        self:AddResetSpell("SivirW")
        self:AddResetSpell("Ricochet")
        self:AddResetSpell("LucianE")
      end
      function _ENV._Data:__GenerateSpellAttacks()
        self:AddSpellAttack("frostarrow")
        self:AddSpellAttack("CaitlynHeadshotMissile")
        self:AddSpellAttack("QuinnWEnhanced")
        self:AddSpellAttack("TrundleQ")
        self:AddSpellAttack("XenZhaoThrust")
        self:AddSpellAttack("XenZhaoThrust2")
        self:AddSpellAttack("XenZhaoThrust3")
        self:AddSpellAttack("GarenSlash2")
        self:AddSpellAttack("RenektonExecute")
        self:AddSpellAttack("RenektonSuperExecute")
        self:AddSpellAttack("KennenMegaProc")
        self:AddSpellAttack("redcardpreattack")
        self:AddSpellAttack("bluecardpreattack")
        self:AddSpellAttack("goldcardpreattack")
        self:AddSpellAttack("MasterYiDoubleStrike")
      end
      function _ENV._Data:__GenerateNoneAttacks()
        self:AddNoneAttack("shyvanadoubleattackdragon")
        self:AddNoneAttack("ShyvanaDoubleAttack")
        self:AddNoneAttack("MonkeyKingDoubleAttack")
      end
      function _ENV._Data:_GenerateMinionData()
        self:AddMinionData((myHero.team == 100 and "Blue" or "Red") .. "_Minion_Basic", 400, 0)
        self:AddMinionData((myHero.team == 100 and "Blue" or "Red") .. "_Minion_Caster", 484, 0.65)
        self:AddMinionData((myHero.team == 100 and "Blue" or "Red") .. "_Minion_Wizard", 484, 0.65)
        self:AddMinionData((myHero.team == 100 and "Blue" or "Red") .. "_Minion_MechCannon", 365, 1.2)
        self:AddMinionData("obj_AI_Turret", 150, 1.2)
      end
      function _ENV._Data:_GenerateJungleData()
        self:AddJungleMonster("SRU_Razorbeak3.1.1", 1)
        self:AddJungleMonster("SRU_RazorbeakMini3.1.4", 2)
        self:AddJungleMonster("SRU_RazorbeakMini3.1.3", 2)
        self:AddJungleMonster("SRU_RazorbeakMini3.1.2", 2)
        self:AddJungleMonster("SRU_Red4.1.1", 1)
        self:AddJungleMonster("SRU_RedMini4.1.2", 2)
        self:AddJungleMonster("SRU_RedMini4.1.3", 2)
        self:AddJungleMonster("SRU_Krug5.1.2", 1)
        self:AddJungleMonster("SRU_KrugMini5.1.1", 2)
        self:AddJungleMonster("SRU_Murkwolf2.1.1", 1)
        self:AddJungleMonster("SRU_MurkwolfMini2.1.3", 2)
        self:AddJungleMonster("SRU_MurkwolfMini2.1.2", 2)
        self:AddJungleMonster("SRU_Blue1.1.1", 1)
        self:AddJungleMonster("SRU_BlueMini21.1.3", 2)
        self:AddJungleMonster("SRU_BlueMini1.1.2", 2)
        self:AddJungleMonster("SRU_Gromp13.1.1", 1)
        self:AddJungleMonster("SRU_Razorbeak9.1.1", 1)
        self:AddJungleMonster("SRU_RazorbeakMini9.1.4", 2)
        self:AddJungleMonster("SRU_RazorbeakMini9.1.3", 2)
        self:AddJungleMonster("SRU_RazorbeakMini9.1.2", 2)
        self:AddJungleMonster("SRU_Red10.1.1", 1)
        self:AddJungleMonster("SRU_RedMini10.1.2", 2)
        self:AddJungleMonster("SRU_RedMini10.1.3", 2)
        self:AddJungleMonster("SRU_Krug11.1.2", 1)
        self:AddJungleMonster("SRU_KrugMini11.1.1", 2)
        self:AddJungleMonster("SRU_Murkwolf8.1.1", 1)
        self:AddJungleMonster("SRU_MurkwolfMini8.1.3", 2)
        self:AddJungleMonster("SRU_MurkwolfMini8.1.2", 2)
        self:AddJungleMonster("SRU_Blue7.1.1", 1)
        self:AddJungleMonster("SRU_BlueMini27.1.3", 2)
        self:AddJungleMonster("SRU_BlueMini7.1.2", 2)
        self:AddJungleMonster("SRU_Gromp14.1.1", 1)
        self:AddJungleMonster("SRU_Dragon6.1.1", 1)
        self:AddJungleMonster("SRU_Baron12.1.1", 1)
        self:AddJungleMonster("Sru_Crab15.1.1", 2)
        self:AddJungleMonster("Sru_Crab16.1.1", 2)
        self:AddJungleMonster("TT_NGolem2.1.1", 1)
        self:AddJungleMonster("TT_NGolem22.1.2", 2)
        self:AddJungleMonster("TT_NWraith21.1.3", 2)
        self:AddJungleMonster("TT_NWraith21.1.2", 2)
        self:AddJungleMonster("TT_NWraith1.1.1", 1)
        self:AddJungleMonster("TT_NWolf23.1.3", 2)
        self:AddJungleMonster("TT_NWolf23.1.2", 2)
        self:AddJungleMonster("TT_NWolf3.1.1", 2)
        self:AddJungleMonster("TT_NWolf26.1.3", 2)
        self:AddJungleMonster("TT_NWolf26.1.2", 2)
        self:AddJungleMonster("TT_NWolf6.1.1", 1)
        self:AddJungleMonster("TT_NWraith4.1.1", 1)
        self:AddJungleMonster("TT_NWraith24.1.3", 1)
        self:AddJungleMonster("TT_NWraith24.1.2", 1)
        self:AddJungleMonster("TT_NGolem25.1.2", 2)
        self:AddJungleMonster("TT_NGolem5.1.1", 1)
        self:AddJungleMonster("AscXerath", 1)
      end
      function _ENV._Data:_GenerateItemData()
        self:AddItemData("Blade of the Ruined King", "ItemSwordOfFeastAndFamine", 3153, true, 500)
        self:AddItemData("Bilgewater Cutlass", "BilgewaterCutlass", 3144, true, 500)
        self:AddItemData("Hextech Gunblade", "HextechGunblade", 3146, true, 400)
        self:AddItemData("Frost Queens Claim", "ItemGlacialSpikeCast", 3098, true, 750)
        self:AddItemData("Talisman of Ascension", "shurelyascrest", 3098, false)
        self:AddItemData("Ravenous Hydra", "ItemTiamatCleave", 3074, false)
        self:AddItemData("Tiamat", "ItemTiamatCleave", 3077, false)
        self:AddItemData("Entropy", "OdinEntropicClaymore", 3184, false)
        self:AddItemData("Youmuu's Ghostblade", "YoumusBlade", 3142, false)
        self:AddItemData("Muramana", "Muramana", 3042, false)
        self:AddItemData("Randuins Omen", "RanduinsOmen", 3143, false)
      end
      _ENV.OBJECT_TYPE_WARD = 0
      _ENV.OBJECT_TYPE_BOX = 1
      _ENV.OBJECT_TYPE_TRAP = 2
      function _ENV._Data:_GenerateWardData()
        self:AddWardData("VisionWard", "VisionWard", "visionward", OBJECT_TYPE_WARD, 1450, 180000)
        self:AddWardData("SightWard", "SightWard", "sightward", OBJECT_TYPE_WARD, 1450, 180000)
        self:AddWardData("YellowTrinket", "SightWard", "sightward", OBJECT_TYPE_WARD, 1450, 180000)
        self:AddWardData("SightWard", "VisionWard", "itemghostward", OBJECT_TYPE_WARD, 1450, 180000)
        self:AddWardData("SightWard", "VisionWard", "itemminiward", OBJECT_TYPE_WARD, 1450, 60000)
        self:AddWardData("SightWard", "SightWard", "wrigglelantern", OBJECT_TYPE_WARD, 1450, 180000)
        self:AddWardData("ShacoBox", "Jack In The Box", "jackinthebox", OBJECT_TYPE_BOX, 300, 60000)
      end
      _ENV.ROLE_AD_CARRY = 1
      _ENV.ROLE_AP = 2
      _ENV.ROLE_SUPPORT = 3
      _ENV.ROLE_BRUISER = 4
      _ENV.ROLE_TANK = 5
      function _ENV._Data:__GenerateChampionData()
        self:AddChampionData("Aatrox", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Ahri", 1.6, 65, 0, ROLE_AP)
        self:AddChampionData("Akali", 0, 65, 0, ROLE_AP)
        self:AddChampionData("Alistar", 0, 80, 0, ROLE_SUPPORT)
        self:AddChampionData("Amumu", 0, 55, 0, ROLE_TANK)
        self:AddChampionData("Anivia", 1.4, 65, 0, ROLE_AP)
        self:AddChampionData("Annie", 1, 55, 0, ROLE_AP)
        self:AddChampionData("Ashe", 2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Blitzcrank", 0, 80, 0, ROLE_SUPPORT)
        self:AddChampionData("Brand", 1.975, 65, 0, ROLE_AP)
        self:AddChampionData("Braum ", 0, 65, 0, ROLE_TANK)
        self:AddChampionData("Caitlyn", 2.5, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Cassiopeia", 1.22, 65, 0, ROLE_AP)
        self:AddChampionData("Chogath", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Corki", 2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Darius", 0, 80, 0, ROLE_BRUISER)
        self:AddChampionData("Diana", 0, 65, 0, ROLE_AP)
        self:AddChampionData("DrMundo", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Draven", 1.4, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Elise", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Evelynn", 0, 65, 0, ROLE_AP)
        self:AddChampionData("Ezreal", 2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("FiddleSticks", 1.75, 65, 0, ROLE_AP)
        self:AddChampionData("Fiora", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Fizz", 0, 65, 0, ROLE_AP)
        self:AddChampionData("Galio", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Gangplank", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Garen", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Gragas", 0, 80, 0, ROLE_AP)
        self:AddChampionData("Graves", 3, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Hecarim", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Heimerdinger", 1.4, 55, 0, ROLE_AP)
        self:AddChampionData("Irelia", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Janna", 1.2, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("JarvanIV", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Jax", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Jayce", 2.5, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Jinx", 2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Karma", 1.2, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Kalista", 1.2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Karthus", 1.25, 65, 0, ROLE_AP)
        self:AddChampionData("Kassadin", 0, 65, 0, ROLE_AP)
        self:AddChampionData("Katarina", 0, 65, 0, ROLE_AP)
        self:AddChampionData("Kayle", 1.8, 65, 0, ROLE_AP)
        self:AddChampionData("Kennen", 1.35, 55, 0, ROLE_AP)
        self:AddChampionData("Khazix", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("KogMaw", 1.8, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Leblanc", 1.7, 65, 0, ROLE_AP)
        self:AddChampionData("LeeSin", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Leona", 0, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Lissandra", 0, 65, 0, ROLE_AP)
        self:AddChampionData("Lucian", 2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Lulu", 2.5, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Lux", 1.55, 65, 0, ROLE_AP)
        self:AddChampionData("Malphite", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Malzahar", 1.5, 65, 0, ROLE_AP)
        self:AddChampionData("Maokai", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("MasterYi", 0, 65, 0, ROLE_AP)
        self:AddChampionData("MissFortune", 2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("MonkeyKing", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Mordekaiser", 0, 80, 0, ROLE_AP)
        self:AddChampionData("Morgana", 1.6, 65, 0, ROLE_AP)
        self:AddChampionData("Nami", 0, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Nasus", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Nautilus", 0, 80, 0, ROLE_BRUISER)
        self:AddChampionData("Nidalee", 1.7, 65, 0, ROLE_AP)
        self:AddChampionData("Nocturne", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Nunu", 0, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Olaf", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Orianna", 1.4, 65, 0, ROLE_AP)
        self:AddChampionData("Pantheon", 0, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Poppy", 0, 55, 0, ROLE_BRUISER)
        self:AddChampionData("Quinn", 1.85, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Rammus", 0, 65, 0, ROLE_TANK)
        self:AddChampionData("Renekton", 0, 80, 0, ROLE_BRUISER)
        self:AddChampionData("Rengar", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Riven", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Rumble", 0, 80, 0, ROLE_AP)
        self:AddChampionData("Ryze", 2.4, 65, 0, ROLE_AP)
        self:AddChampionData("Sejuani", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Shaco", 0, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Shen", 0, 65, 0, ROLE_TANK)
        self:AddChampionData("Shyvana", 0, 50, 0, ROLE_BRUISER)
        self:AddChampionData("Singed", 0, 65, 0, ROLE_TANK)
        self:AddChampionData("Sion", 0, 80, 0, ROLE_AP)
        self:AddChampionData("Sivir", 1.4, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Skarner", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Sona", 1.6, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Soraka", 1, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Swain", 1.6, 65, 0, ROLE_AP)
        self:AddChampionData("Syndra", 1.2, 65, 0, ROLE_AP)
        self:AddChampionData("Talon", 0, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Taric", 0, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Teemo", 1.3, 55, 0, ROLE_AP)
        self:AddChampionData("Thresh", 0, 55, 0, ROLE_SUPPORT)
        self:AddChampionData("Tristana", 2.25, 55, 0, ROLE_AD_CARRY)
        self:AddChampionData("Trundle", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Tryndamere", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("TwistedFate", 1.5, 65, 0, ROLE_AP)
        self:AddChampionData("Twitch", 2.5, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Udyr", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Urgot", 1.3, 80, 0, ROLE_AD_CARRY)
        self:AddChampionData("Varus", 2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Vayne", 2, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Veigar", 1.05, 55, 0, ROLE_AP)
        self:AddChampionData("Velkoz", 1.8, 55, 0, ROLE_AP)
        self:AddChampionData("Vi", 0, 50, 0, ROLE_BRUISER)
        self:AddChampionData("Viktor", 2.25, 65, 0, ROLE_AP)
        self:AddChampionData("Vladimir", 1.4, 65, 0, ROLE_AP)
        self:AddChampionData("Volibear", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Warwick", 0, 65, 0, ROLE_TANK)
        self:AddChampionData("Xerath", 1.2, 65, 0, ROLE_AP)
        self:AddChampionData("XinZhao", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Yasuo", 0, 65, 0, ROLE_BRUISER)
        self:AddChampionData("Yorick", 0, 80, 0, ROLE_TANK)
        self:AddChampionData("Zac", 0, 65, 0, ROLE_TANK)
        self:AddChampionData("Zed", 0, 65, 0, ROLE_AD_CARRY)
        self:AddChampionData("Ziggs", 1.5, 55, 0, ROLE_AP)
        self:AddChampionData("Zilean", 1.25, 65, 0, ROLE_SUPPORT)
        self:AddChampionData("Zyra", 1.7, 65, 0, ROLE_AP)
      end
      function _ENV._Data:__GenerateSkillData()
        rebornskillslist = {
          {
            "Aatrox",
            true,
            _E,
            1100,
            "E (Blades of Torment)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.1,
            500,
            100,
            false,
            false
          },
          {
            "Ahri",
            true,
            _Q,
            880,
            "Q (Orb of Deception)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.1,
            500,
            100,
            false,
            false
          },
          {
            "Ahri",
            true,
            _W,
            750,
            "W (Fox-Fire)",
            SPELL_SELF,
            0,
            false,
            false,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "Ahri",
            true,
            _E,
            975,
            "E (Charm)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.2,
            500,
            60,
            false,
            false
          },
          {
            "Akali",
            true,
            _Q,
            600,
            "Q (Mark of the Assassin)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.1,
            650,
            0,
            false,
            false
          },
          {
            "Akali",
            true,
            _E,
            325,
            "E (Crescent Slash)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Akali",
            true,
            _R,
            800,
            "R (Shadow Dance)",
            SPELL_TARGETED,
            0,
            false,
            false,
            2.2,
            0,
            0,
            false,
            false
          },
          {
            "Alistar",
            true,
            _Q,
            365,
            "Q (Pulverize)",
            SPELL_SELF,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Alistar",
            true,
            _W,
            650,
            "W (Headbutt)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            550,
            0,
            false,
            false
          },
          {
            "Alistar",
            true,
            _R,
            0,
            "R (Unbreakable Will)",
            SPELL_SELF,
            0,
            false,
            true,
            0.8285,
            500,
            0,
            false,
            false
          },
          {
            "Amumu",
            true,
            _Q,
            1100,
            "Q (Bandage Toss)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.2,
            500,
            80,
            false,
            false
          },
          {
            "Amumu",
            true,
            _E,
            350,
            "E (Tantrum)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Anivia",
            true,
            _E,
            650,
            "E (Frostbite)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.2,
            500,
            0,
            false,
            false
          },
          {
            "Anivia",
            true,
            _R,
            625,
            "R (Glacial Storm)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            330,
            150,
            false,
            false
          },
          {
            "Annie",
            true,
            _Q,
            625,
            "Q (Disintegrate)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "Annie",
            true,
            _W,
            625,
            "W (Incinerate)",
            SPELL_CONE,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Annie",
            true,
            _R,
            600,
            "R (Summon: Tibbers)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.2,
            500,
            0,
            false,
            false
          },
          {
            "Ashe",
            true,
            _W,
            600,
            "W (Volley)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.902,
            500,
            80,
            false,
            false
          },
          {
            "Ashe",
            true,
            _R,
            25000,
            "R (Enchanted Crystal Arrow)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.6,
            500,
            130,
            false,
            false
          },
          {
            "Azir",
            true,
            _Q,
            800,
            "Q (Conquering Sands)",
            SPELL_LINEAR,
            0,
            false,
            false,
            2,
            200,
            100,
            false,
            false
          },
          {
            "Azir",
            true,
            _W,
            600,
            "W (Arize!)",
            SPELL_LINEAR,
            0,
            false,
            false,
            math.huge,
            200,
            100,
            false,
            false
          },
          {
            "Blitzcrank",
            true,
            _Q,
            925,
            "Q (Rocket Grab)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.8,
            500,
            70,
            false,
            false
          },
          {
            "Blitzcrank",
            true,
            _E,
            300,
            "E (Power Fist)",
            SPELL_SELF,
            0,
            true,
            true,
            1,
            1,
            1,
            false,
            false
          },
          {
            "Blitzcrank",
            true,
            _R,
            600,
            "R (Static Field)",
            SPELL_SELF,
            0,
            false,
            false,
            1.5,
            500,
            200,
            false,
            false
          },
          {
            "Brand",
            true,
            _Q,
            900,
            "Q (Sear)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.2,
            500,
            80,
            false,
            false
          },
          {
            "Brand",
            true,
            _W,
            900,
            "W (Pillar of Flame)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Brand",
            true,
            _E,
            625,
            "E (Conflagration)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "Brand",
            true,
            _R,
            750,
            "R (Pyroclasm)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.1,
            500,
            0,
            false,
            false
          },
          {
            "Caitlyn",
            true,
            _Q,
            1300,
            "Q (Piltover Peacemaker)",
            SPELL_LINEAR,
            0,
            false,
            false,
            2.2,
            500,
            90,
            false,
            false
          },
          {
            "Caitlyn",
            true,
            _E,
            1100,
            "E (90 Caliber Net)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.2,
            700,
            80,
            false,
            false
          },
          {
            "Caitlyn",
            true,
            _R,
            2200,
            "R (Ace in the Hole)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.5,
            500,
            0,
            false,
            false
          },
          {
            "Cassiopeia",
            true,
            _Q,
            850,
            "Q (Noxious Blast)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.2,
            500,
            0,
            false,
            false
          },
          {
            "Cassiopeia",
            true,
            _W,
            850,
            "W (Miasma)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            2.5,
            500,
            90,
            false,
            false
          },
          {
            "Cassiopeia",
            true,
            _E,
            700,
            "E (Twin Fang)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.9,
            750,
            0,
            false,
            false
          },
          {
            "Cassiopeia",
            true,
            _R,
            825,
            "R (Petrifying Gaze)",
            SPELL_CONE,
            0,
            false,
            false,
            0,
            750,
            0,
            false,
            false
          },
          {
            "Chogath",
            true,
            _Q,
            950,
            "Q (Rupture)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.2,
            0,
            0,
            false,
            false
          },
          {
            "Chogath",
            true,
            _W,
            300,
            "W (Feral Scream)",
            SPELL_CONE,
            0,
            false,
            false,
            0,
            0,
            0,
            false,
            false
          },
          {
            "Chogath",
            true,
            _R,
            150,
            "R (Feast)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.5,
            0,
            0,
            false,
            false
          },
          {
            "Corki",
            true,
            _Q,
            825,
            "Q (Phosphorus Bomb)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.2,
            500,
            0,
            false,
            false
          },
          {
            "Corki",
            true,
            _W,
            800,
            "W (Valkyrie)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            90,
            false,
            false
          },
          {
            "Corki",
            true,
            _E,
            600,
            "E (Gatling Gun)",
            SPELL_CONE,
            0,
            false,
            false,
            0.902,
            500,
            0,
            false,
            false
          },
          {
            "Corki",
            true,
            _R,
            1225,
            "R (Missile Barrage)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.8285,
            500,
            40,
            false,
            false
          },
          {
            "Darius",
            true,
            _Q,
            420,
            "Q (Decimate)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            500,
            80,
            false,
            false
          },
          {
            "Darius",
            true,
            _W,
            145,
            "W (Crippling Strike)",
            SPELL_SELF,
            0,
            true,
            true,
            0,
            230,
            0,
            false,
            false
          },
          {
            "Darius",
            true,
            _E,
            550,
            "E (Apprehend)",
            SPELL_CONE,
            0,
            false,
            false,
            1.5,
            500,
            0,
            false,
            false
          },
          {
            "Darius",
            true,
            _R,
            475,
            "R (Noxian Guillotine)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Diana",
            true,
            _Q,
            830,
            "Q (Crescent Strike)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0.2,
            500,
            0,
            false,
            false
          },
          {
            "Diana",
            true,
            _W,
            625,
            "W (Pale Cascade)",
            SPELL_SELF,
            0,
            false,
            false,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "Diana",
            true,
            _R,
            825,
            "R (Lunar Rush)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "DrMundo",
            true,
            _Q,
            1100,
            "Q (Infected Cleaver)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.5,
            500,
            75,
            false,
            false
          },
          {
            "DrMundo",
            true,
            _E,
            1100,
            "E (Masochism)",
            SPELL_LINEAR_COL,
            0,
            false,
            true,
            1.5,
            500,
            75,
            false,
            false
          },
          {
            "Draven",
            true,
            _E,
            1050,
            "E (Stand Aside)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.6,
            500,
            130,
            false,
            false
          },
          {
            "Draven",
            true,
            _R,
            20000,
            "R (Whirling Death)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0.2,
            500,
            160,
            false,
            false
          },
          {
            "Elise",
            true,
            _Q,
            625,
            "Q (Neurotoxin)",
            SPELL_TARGETED,
            0,
            false,
            false,
            2.2,
            750,
            0,
            false,
            false
          },
          {
            "Elise",
            true,
            _W,
            950,
            "W (Volatile Spiderling)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            750,
            0,
            false,
            false
          },
          {
            "Elise",
            true,
            _E,
            1100,
            "E (Cocoon)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.4,
            500,
            70,
            false,
            false
          },
          {
            "Evelynn",
            true,
            _Q,
            500,
            "Q (Hate Spike)",
            SPELL_SELF,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Evelynn",
            true,
            _E,
            225,
            "E (Ravage)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.9,
            500,
            0,
            false,
            false
          },
          {
            "Evelynn",
            true,
            _R,
            650,
            "R (Agony's Embrace)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.3,
            500,
            80,
            false,
            false
          },
          {
            "Ezreal",
            true,
            _Q,
            1100,
            "Q (Mystic Shot)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.2,
            500,
            80,
            false,
            false
          },
          {
            "Ezreal",
            true,
            _W,
            1100,
            "W (Essence Flux)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            80,
            false,
            false
          },
          {
            "Ezreal",
            true,
            _E,
            475,
            "E (Arcane Shift)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.2,
            500,
            0,
            false,
            false
          },
          {
            "Ezreal",
            true,
            _R,
            2500,
            "R (Trueshot Barrage)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0.2,
            500,
            160,
            false,
            false
          },
          {
            "FiddleSticks",
            true,
            _Q,
            575,
            "Q (Terrify)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "FiddleSticks",
            true,
            _W,
            575,
            "W (Drain)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "FiddleSticks",
            true,
            _E,
            750,
            "E (Dark Wind)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.1,
            500,
            0,
            false,
            false
          },
          {
            "Fiora",
            true,
            _Q,
            600,
            "Q (Lunge)",
            SPELL_TARGETED,
            0,
            false,
            false,
            2.2,
            0,
            0,
            false,
            false
          },
          {
            "Fiora",
            true,
            _E,
            500,
            "E (Burst of Speed)",
            SPELL_SELF,
            0,
            true,
            true,
            0,
            230,
            0,
            false,
            false
          },
          {
            "Fiora",
            true,
            _R,
            400,
            "R (Blade Waltz)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Fizz",
            true,
            _Q,
            550,
            "Q (Urchin Strike)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Fizz",
            true,
            _W,
            600,
            "W (Seastone Trident)",
            SPELL_SELF,
            0,
            false,
            true,
            1.4,
            500,
            80,
            false,
            false
          },
          {
            "Fizz",
            true,
            _R,
            1300,
            "R (Chum the Waters)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            80,
            false,
            false
          },
          {
            "Galio",
            true,
            _Q,
            900,
            "Q (Resolute Smite)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.3,
            500,
            120,
            false,
            false
          },
          {
            "Galio",
            true,
            _E,
            1180,
            "E (Righteous Gust)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            120,
            false,
            false
          },
          {
            "Gangplank",
            true,
            _Q,
            625,
            "Q (Parrrley)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.2,
            500,
            0,
            false,
            false
          },
          {
            "Garen",
            true,
            _Q,
            300,
            "Q (Decisive Strike)",
            SPELL_SELF,
            0,
            false,
            true,
            0,
            230,
            0,
            false,
            false
          },
          {
            "Garen",
            true,
            _E,
            165,
            "E (Judgment)",
            SPELL_SELF,
            0,
            false,
            false,
            0.7,
            0,
            160,
            false,
            false
          },
          {
            "Garen",
            true,
            _R,
            400,
            "R (Demacian Justice)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.9,
            130,
            120,
            false,
            false
          },
          {
            "Gragas",
            true,
            _Q,
            850,
            "Q (Barrel Roll)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.1,
            500,
            110,
            false,
            false
          },
          {
            "Gragas",
            true,
            _E,
            600,
            "E (Body Slam)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.02,
            500,
            50,
            false,
            false
          },
          {
            "Gragas",
            true,
            _R,
            1050,
            "R (Explosive Cask)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            500,
            120,
            false,
            false
          },
          {
            "Graves",
            true,
            _Q,
            700,
            "Q (Buckshot)",
            SPELL_CONE,
            0,
            false,
            false,
            0.902,
            500,
            0,
            false,
            false
          },
          {
            "Graves",
            true,
            _W,
            900,
            "W (Smoke Screen)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.65,
            500,
            0,
            false,
            false
          },
          {
            "Graves",
            true,
            _R,
            1100,
            "R (Collateral Damage)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.2,
            500,
            100,
            false,
            false
          },
          {
            "Hecarim",
            true,
            _Q,
            350,
            "Q (Rampage)",
            SPELL_SELF,
            0,
            false,
            false,
            1.45,
            300,
            0,
            false,
            false
          },
          {
            "Hecarim",
            true,
            _W,
            575,
            "W (Spirit of Dread)",
            SPELL_SELF,
            0,
            false,
            false,
            0.8285,
            430,
            0,
            false,
            false
          },
          {
            "Heimerdinger",
            true,
            _W,
            1100,
            "W (Hextech Micro-Rockets)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.902,
            500,
            20,
            false,
            false
          },
          {
            "Heimerdinger",
            true,
            _E,
            925,
            "E (CH-2 Electron Storm Grenade)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            2.5,
            500,
            120,
            false,
            false
          },
          {
            "Irelia",
            true,
            _Q,
            650,
            "Q (Bladesurge)",
            SPELL_TARGETED,
            0,
            false,
            false,
            2.2,
            0,
            0,
            false,
            false
          },
          {
            "Irelia",
            true,
            _W,
            20,
            "W (Hiten Style)",
            SPELL_SELF,
            0,
            false,
            true,
            0.34779,
            230,
            0,
            false,
            false
          },
          {
            "Irelia",
            true,
            _E,
            425,
            "E (Equilibrium Strike)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Irelia",
            true,
            _R,
            1200,
            "R (Transcendent Blades)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0.7799,
            500,
            70,
            false,
            false
          },
          {
            "Janna",
            true,
            _Q,
            1700,
            "Q (Howling Gale)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0,
            0,
            20,
            false,
            false
          },
          {
            "Janna",
            true,
            _W,
            600,
            "W (Zephyr)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.6,
            500,
            0,
            false,
            false
          },
          {
            "Jarvan",
            true,
            _Q,
            770,
            "Q (Dragon Strike)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0.02,
            500,
            70,
            false,
            false
          },
          {
            "Jarvan",
            true,
            _W,
            525,
            "W (Golden Aegis)",
            SPELL_SELF,
            0,
            false,
            false,
            1.5,
            750,
            0,
            false,
            false
          },
          {
            "Jarvan",
            true,
            _E,
            830,
            "E (Demacian Standard)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.45,
            500,
            0,
            false,
            false
          },
          {
            "Jarvan",
            true,
            _R,
            650,
            "R (Cataclysm)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Jax",
            true,
            _Q,
            700,
            "Q (Leap Strike)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Jax",
            true,
            _W,
            300,
            "W (Empower)",
            SPELL_SELF,
            0,
            false,
            true,
            0,
            233,
            0,
            false,
            false
          },
          {
            "Jinx",
            true,
            _W,
            1500,
            "W (Zap!)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            3.3,
            625,
            60,
            false,
            false
          },
          {
            "Jinx",
            true,
            _R,
            25000,
            "R (Super Mega Death Rocket!)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            120,
            false,
            false
          },
          {
            "Karma",
            true,
            _Q,
            950,
            "Q (Inner Flame)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.902,
            500,
            90,
            false,
            false
          },
          {
            "Karma",
            true,
            _Q,
            950,
            "Q (Soulflare)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.902,
            500,
            90,
            false,
            false
          },
          {
            "Karma",
            true,
            _W,
            675,
            "W (Focused Resolve)",
            SPELL_TARGETED,
            0,
            false,
            false,
            2.2,
            500,
            60,
            false,
            false
          },
          {
            "Karma",
            true,
            _W,
            675,
            "W (Renewal)",
            SPELL_TARGETED,
            0,
            false,
            false,
            2.2,
            500,
            60,
            false,
            false
          },
          {
            "Karthus",
            true,
            _Q,
            875,
            "Q (Laywast)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Kassadin",
            true,
            _Q,
            650,
            "Q (Null Sphere)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "Kassadin",
            true,
            _W,
            150,
            "W (Nether Blade)",
            SPELL_SELF,
            0,
            true,
            true,
            0,
            0,
            0,
            false,
            false
          },
          {
            "Kassadin",
            true,
            _E,
            700,
            "E (Force Pulse)",
            SPELL_CONE,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Kassadin",
            true,
            _R,
            700,
            "R (Rift Walk)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.5,
            500,
            0,
            false,
            false
          },
          {
            "Katarina",
            true,
            _Q,
            675,
            "Q (Bouncing Blades)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.8,
            500,
            0,
            false,
            false
          },
          {
            "Katarina",
            true,
            _W,
            375,
            "W (Sinister Steel)",
            SPELL_SELF,
            0,
            false,
            false,
            1.8,
            500,
            0,
            false,
            false
          },
          {
            "Katarina",
            true,
            _E,
            700,
            "E (Shunpo)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Kayle",
            true,
            _Q,
            650,
            "Q (Reckoning)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.5,
            500,
            0,
            false,
            false
          },
          {
            "Kayle",
            true,
            _E,
            525,
            "E (Righteous Fury)",
            SPELL_SELF,
            0,
            false,
            false,
            0.7799,
            500,
            0,
            false,
            false
          },
          {
            "Kennen",
            true,
            _Q,
            1050,
            "Q (Thundering Shuriken)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.7,
            700,
            50,
            false,
            false
          },
          {
            "Kennen",
            true,
            _W,
            800,
            "W (Electrical Surge)",
            SPELL_SELF,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Kennen",
            true,
            _E,
            0,
            "E (Lightning Rush)",
            SPELL_SELF,
            0,
            false,
            false,
            0.02,
            0,
            0,
            false,
            false
          },
          {
            "Khazix",
            true,
            _Q,
            325,
            "Q (Taste Their Fear)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Khazix",
            true,
            _W,
            1100,
            "W (Void Spike)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            0.8255,
            500,
            60,
            false,
            false
          },
          {
            "Khazix",
            true,
            _E,
            600,
            "E (Leap)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "KogMaw",
            true,
            _Q,
            1000,
            "Q (Caustic Spittle)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.2,
            500,
            70,
            false,
            false
          },
          {
            "KogMaw",
            true,
            _W,
            1000,
            "W (Bio-Arcane Barrage)",
            SPELL_SELF,
            0,
            false,
            true,
            0.007,
            500,
            0,
            false,
            false
          },
          {
            "KogMaw",
            true,
            _E,
            1200,
            "E (Void Ooze)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            120,
            false,
            false
          },
          {
            "KogMaw",
            true,
            _R,
            1700,
            "R (Living Artillery)",
            SPELL_LINEAR,
            0,
            false,
            false,
            math.huge,
            850,
            200,
            false,
            false
          },
          {
            "Leblanc",
            true,
            _Q,
            700,
            "Q (Sigil of Silence)",
            SPELL_TARGETED,
            0,
            false,
            false,
            2,
            500,
            0,
            false,
            false
          },
          {
            "Leblanc",
            true,
            _W,
            700,
            "W (Distortion)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            2,
            500,
            0,
            false,
            false
          },
          {
            "Leblanc",
            true,
            _E,
            950,
            "E (Ethereal Chains)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.6,
            500,
            70,
            false,
            false
          },
          {
            "LeeSin",
            true,
            _Q,
            1100,
            "Q (Sonic Wave)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.8,
            500,
            60,
            false,
            false
          },
          {
            "LeeSin",
            true,
            _E,
            350,
            "E (Tempest)",
            SPELL_SELF,
            0,
            false,
            true,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Leona",
            true,
            _Q,
            125,
            "Q (Shield of Daybreak)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0,
            233.3,
            0,
            false,
            false
          },
          {
            "Leona",
            true,
            _E,
            875,
            "E (Zenith Blade)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            80,
            false,
            false
          },
          {
            "Lissandra",
            true,
            _Q,
            725,
            "Q (Ice Shard)",
            SPELL_LINEAR,
            0,
            false,
            false,
            2.3,
            250,
            100,
            false,
            false
          },
          {
            "Lissandra",
            true,
            _W,
            450,
            "W (Ring of Frost)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            0,
            0,
            false,
            false
          },
          {
            "Lucian",
            true,
            _Q,
            550,
            "Q (Piercing Light)",
            SPELL_TARGETED,
            0,
            true,
            false,
            19.346,
            405,
            250,
            false,
            false
          },
          {
            "Lucian",
            true,
            _W,
            1100,
            "W (Ardent Blaze)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.47,
            288,
            250,
            false,
            false
          },
          {
            "Lulu",
            true,
            _Q,
            925,
            "Q (Glitterlance)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.4,
            500,
            80,
            false,
            false
          },
          {
            "Lux",
            true,
            _Q,
            1175,
            "Q (Light Binding)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.2,
            500,
            80,
            false,
            false
          },
          {
            "Lux",
            true,
            _W,
            1075,
            "W (Prismatic Barrier)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            150,
            false,
            false
          },
          {
            "Lux",
            true,
            _E,
            1100,
            "E (Lucent Singularity)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.3,
            500,
            0,
            false,
            false
          },
          {
            "Malphite",
            true,
            _Q,
            625,
            "Q (Seismic Shard)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.2,
            500,
            0,
            false,
            false
          },
          {
            "Malphite",
            true,
            _W,
            125,
            "W (Brutal Strike)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Malphite",
            true,
            _E,
            200,
            "E (Ground Slam)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Malzahar",
            true,
            _W,
            800,
            "W (Null Zone)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Malzahar",
            true,
            _E,
            650,
            "E (Malefic Visions)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "Maokai",
            true,
            _Q,
            600,
            "Q (Arcane Smash)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.1,
            333,
            110,
            false,
            false
          },
          {
            "Maokai",
            true,
            _W,
            650,
            "W (Twisted Advance)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1,
            500,
            0,
            false,
            false
          },
          {
            "Maokai",
            true,
            _E,
            1100,
            "E (Sapling Toss)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.75,
            250,
            0,
            false,
            false
          },
          {
            "MasterYi",
            true,
            _Q,
            600,
            "Q (Alpha Strike)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.34779,
            230,
            0,
            false,
            false
          },
          {
            "MasterYi",
            true,
            _E,
            125,
            "E (Wuju Style)",
            SPELL_SELF,
            0,
            false,
            true,
            0.34779,
            230,
            0,
            false,
            false
          },
          {
            "MissFortune",
            true,
            _Q,
            650,
            "Q (Double Up)",
            SPELL_TARGETED,
            0,
            true,
            false,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "MissFortune",
            true,
            _W,
            550,
            "W (Impure Shots)",
            SPELL_SELF,
            0,
            false,
            true,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "MissFortune",
            true,
            _E,
            800,
            "E (Make It Rain)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.5,
            500,
            0,
            false,
            false
          },
          {
            "Mordekaiser",
            true,
            _Q,
            600,
            "Q (Mace of Spades)",
            SPELL_SELF,
            0,
            false,
            false,
            1.5,
            0,
            0,
            false,
            false
          },
          {
            "Mordekaiser",
            true,
            _E,
            700,
            "E (Siphon of Destruction)",
            SPELL_CONE,
            0,
            false,
            false,
            1.5,
            500,
            0,
            false,
            false
          },
          {
            "Morgana",
            true,
            _Q,
            1300,
            "Q (Dark Binding)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.2,
            500,
            70,
            false,
            false
          },
          {
            "Morgana",
            true,
            _W,
            900,
            "W (Tormented Soil)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Nami",
            true,
            _Q,
            875,
            "Q (Aqua Prison)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.75,
            0,
            0,
            false,
            false
          },
          {
            "Nasus",
            true,
            _Q,
            125,
            "Q (Siphoning Strike)",
            SPELL_SELF,
            0,
            true,
            true,
            0,
            233,
            0,
            false,
            false
          },
          {
            "Nasus",
            true,
            _W,
            600,
            "W (Wither)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Nasus",
            true,
            _E,
            650,
            "E (Spirit Fire)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Nidalee",
            true,
            _Q,
            1500,
            "Human Q (Javelin Toss)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.3,
            0,
            60,
            false,
            false,
            function()
              return myHero:GetSpellData(_Q).name == "JavelinToss"
            end
          },
          {
            "Nidalee",
            true,
            _Q,
            500,
            "Cougar Q (Takedown)",
            SPELL_SELF,
            0,
            true,
            false,
            0.5,
            500,
            0,
            false,
            false,
            function()
              return myHero:GetSpellData(_Q).name ~= "JavelinToss"
            end
          },
          {
            "Nidalee",
            true,
            _W,
            375,
            "Cougar W (Pounce)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false,
            function()
              return myHero:GetSpellData(_Q).name ~= "JavelinToss"
            end
          },
          {
            "Nidalee",
            true,
            _E,
            400,
            "Cougar E (Swipe)",
            SPELL_SELF,
            0,
            true,
            false,
            0,
            500,
            0,
            false,
            false,
            function()
              return myHero:GetSpellData(_Q).name ~= "JavelinToss"
            end
          },
          {
            "Nocturne",
            true,
            _Q,
            1200,
            "Q (Duskbringer)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.4,
            500,
            60,
            false,
            false
          },
          {
            "Nunu",
            true,
            _Q,
            125,
            "Q (Consume)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.5,
            200,
            0,
            false,
            false
          },
          {
            "Nunu",
            true,
            _E,
            550,
            "E (Ice Blast)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1,
            500,
            0,
            false,
            false
          },
          {
            "Olaf",
            true,
            _Q,
            1000,
            "Q (Undertow)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.6,
            500,
            90,
            false,
            false
          },
          {
            "Olaf",
            true,
            _W,
            125,
            "W (Vicious Strikes)",
            SPELL_SELF,
            0,
            false,
            true,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Olaf",
            true,
            _E,
            325,
            "E (Reckless Swing)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Orianna",
            true,
            _Q,
            825,
            "Q (Command: Attack)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.2,
            500,
            80,
            false,
            false
          },
          {
            "Pantheon",
            true,
            _Q,
            600,
            "Q (Spear Shot)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.5,
            500,
            0,
            false,
            false
          },
          {
            "Pantheon",
            true,
            _W,
            600,
            "W (Aegis of Zeonia)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Pantheon",
            true,
            _E,
            600,
            "E (Heartseeker Strike)",
            SPELL_CONE,
            0,
            false,
            false,
            0.7799,
            333,
            100,
            false,
            false
          },
          {
            "Renekton",
            true,
            _Q,
            225,
            "Q (Cull the Meek)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Renekton",
            true,
            _W,
            125,
            "W (Ruthless Predator)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            233,
            0,
            false,
            false
          },
          {
            "Rengar",
            true,
            _Q,
            125,
            "Q (Savagery)",
            SPELL_SELF,
            0,
            true,
            false,
            0,
            0,
            0,
            false,
            false
          },
          {
            "Rengar",
            true,
            _W,
            500,
            "W (Battle Roar)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Rengar",
            true,
            _E,
            1100,
            "E (Bola Strike)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.5,
            0,
            70,
            false,
            false
          },
          {
            "Rumble",
            true,
            _E,
            1500,
            "E (Electro-Harpoon)",
            SPELL_LINEAR_COL,
            0,
            false,
            false,
            1.2,
            500,
            90,
            false,
            false
          },
          {
            "Ryze",
            true,
            _Q,
            625,
            "Q (Overload)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.4,
            0,
            0,
            false,
            false
          },
          {
            "Ryze",
            true,
            _W,
            600,
            "W (Rune Prison)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.5,
            0,
            0,
            false,
            false
          },
          {
            "Ryze",
            true,
            _E,
            600,
            "E (Spell Flux)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1,
            0,
            0,
            false,
            false
          },
          {
            "Shyvana",
            true,
            _Q,
            125,
            "Q (Twin Bite)",
            SPELL_SELF,
            0,
            true,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Shyvana",
            true,
            _W,
            162,
            "W (Burnout)",
            SPELL_SELF,
            0,
            false,
            false,
            0.02,
            466,
            0,
            false,
            false
          },
          {
            "Shyvana",
            true,
            _E,
            925,
            "E (Flame Breath)",
            SPELL_LINEAR,
            0,
            false,
            false,
            0.9,
            500,
            60,
            false,
            false
          },
          {
            "Shyvana",
            true,
            _E,
            925,
            "E (Dragon's Flame Breath)",
            SPELL_CONE,
            0,
            false,
            false,
            1.2,
            500,
            60,
            false,
            false
          },
          {
            "Sivir",
            true,
            _Q,
            1000,
            "Q (Boomerang Blade)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.33,
            250,
            120,
            false,
            false
          },
          {
            "Sivir",
            true,
            _W,
            900,
            "W (Ricochet)",
            SPELL_SELF,
            0,
            true,
            true,
            1,
            0,
            200,
            false,
            true
          },
          {
            "Soraka",
            true,
            _Q,
            530,
            "Q (Starcall)",
            SPELL_SELF,
            0,
            false,
            false,
            0,
            0,
            0,
            false,
            false
          },
          {
            "Syndra",
            true,
            _Q,
            800,
            "Q (Dark Sphere)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            math.huge,
            400,
            100,
            false,
            false
          },
          {
            "Syndra",
            true,
            _R,
            675,
            "R (Unleashed Power)",
            SPELL_TARGETED,
            0,
            false,
            false,
            math.huge,
            400,
            100,
            false,
            false
          },
          {
            "Vayne",
            true,
            _Q,
            750,
            "Q (Tumble)",
            _ENV.SPELL_SELF_AT_MOUSE,
            0,
            true,
            true,
            1.45,
            250,
            200,
            false,
            true
          },
          {
            "Vayne",
            true,
            _R,
            580,
            "R (Final Hour)",
            SPELL_SELF,
            0,
            false,
            true,
            1.45,
            250,
            200,
            false,
            false
          },
          {
            "Talon",
            true,
            _Q,
            600,
            "Q (Noxian Diplomacy)",
            SPELL_SELF,
            0,
            true,
            true,
            0.902,
            400,
            80,
            false,
            false
          },
          {
            "Talon",
            true,
            _W,
            600,
            "W (Rake)",
            SPELL_CONE,
            0,
            false,
            false,
            0.902,
            400,
            150,
            false,
            false
          },
          {
            "Talon",
            true,
            _E,
            700,
            "E (Cutthroat)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0,
            0,
            0,
            false,
            false
          },
          {
            "Teemo",
            true,
            _Q,
            580,
            "Q (Blinding Dart)",
            SPELL_TARGETED,
            0,
            true,
            false,
            2,
            0,
            200,
            false,
            true
          },
          {
            "TwistedFate",
            true,
            _Q,
            1200,
            "Q (Wild Cards)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.45,
            250,
            200,
            false,
            false
          },
          {
            "Trundle",
            true,
            _Q,
            125,
            "Q (Chomp)",
            SPELL_SELF,
            0,
            true,
            false,
            0,
            233,
            0,
            false,
            false
          },
          {
            "Tristana",
            true,
            _Q,
            580,
            "Q (Rapid Fire)",
            SPELL_SELF,
            0,
            false,
            true,
            1.45,
            250,
            200,
            false,
            false
          },
          {
            "Tristana",
            true,
            _E,
            550,
            "E (Explosive Shot)",
            SPELL_TARGETED,
            0,
            true,
            false,
            1.45,
            250,
            200,
            false,
            false
          },
          {
            "Tristana",
            true,
            _R,
            645,
            "R (Buster Shot)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.45,
            250,
            200,
            false,
            false
          },
          {
            "Twitch",
            true,
            _W,
            950,
            "W (Venom Cask)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.4,
            250,
            275,
            false,
            false
          },
          {
            "Vladimir",
            true,
            _Q,
            600,
            "Q (Transfusion)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.4,
            500,
            0,
            false,
            false
          },
          {
            "Vladimir",
            true,
            _E,
            610,
            "E (Tides of Blood)",
            SPELL_SELF,
            0,
            false,
            false,
            1.1,
            500,
            120,
            false,
            false
          },
          {
            "Wukong",
            true,
            _Q,
            300,
            "Q (Crushing Blow)",
            SPELL_SELF,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Wukong",
            true,
            _E,
            625,
            "E (Nimbus Strike)",
            SPELL_TARGETED,
            0,
            false,
            false,
            2.2,
            0,
            0,
            false,
            false
          },
          {
            "XinZhao",
            true,
            _Q,
            165,
            "Q (Three Talon Strike)",
            SPELL_SELF,
            0,
            true,
            false,
            0,
            500,
            0,
            false,
            false
          },
          {
            "XinZhao",
            true,
            _W,
            175,
            "W (Battle Cry)",
            SPELL_SELF,
            0,
            false,
            false,
            0.3477,
            230,
            0,
            false,
            false
          },
          {
            "XinZhao",
            true,
            _E,
            600,
            "E (Audacious Charge)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Vi",
            true,
            _E,
            180,
            "E (Excessive Force)",
            SPELL_SELF,
            0,
            false,
            true,
            0,
            500,
            0,
            false,
            false
          },
          {
            "Yasuo",
            true,
            _Q,
            475,
            "Q (Steel Tempest, Stab)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.8,
            100,
            50,
            false,
            false,
            function()
              return myHero:GetSpellData(_Q).name ~= "yasuoq3w"
            end
          },
          {
            "Yasuo",
            true,
            _Q,
            900,
            "Q (Steel Tempest, Tornado)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.8,
            100,
            150,
            false,
            false,
            function()
              return myHero:GetSpellData(_Q).name == "yasuoq3w"
            end
          },
          {
            "Yasuo",
            true,
            _E,
            475,
            "E (Sweeping Blade)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.8,
            100,
            150,
            false,
            false
          },
          {
            "Yorick",
            true,
            _Q,
            125,
            "Q (Omen of War)",
            SPELL_SELF,
            0,
            false,
            true,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Yorick",
            true,
            _W,
            600,
            "W (Omen of Pestilence)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Yorick",
            true,
            _E,
            550,
            "E (Omen of Famine)",
            SPELL_TARGETED,
            0,
            false,
            false,
            0.02,
            500,
            0,
            false,
            false
          },
          {
            "Zac",
            true,
            _Q,
            550,
            "Q (Stretching Strike)",
            SPELL_LINEAR,
            0,
            false,
            false,
            1.2,
            500,
            80,
            false,
            false
          },
          {
            "Zac",
            true,
            _W,
            175,
            "W (Unstable Matter)",
            SPELL_SELF,
            0,
            false,
            false,
            1.288,
            140,
            50,
            false,
            false
          },
          {
            "Ziggs",
            true,
            _Q,
            850,
            "Q (Bouncing Bomb)",
            SPELL_TARGETED,
            0,
            false,
            false,
            1.75,
            250,
            0,
            false,
            false
          },
          {
            "Ziggs",
            true,
            _E,
            900,
            "E (Hexplosive Minefield)",
            SPELL_CIRCLE,
            0,
            false,
            false,
            1.75,
            250,
            0,
            false,
            false
          }
        }
        if rebornskillslist then
          for a_a, b_a in _ENV.pairs(rebornskillslist) do
            if b_a[1] == _ENV.myHero.charName then
              self:AddSkillData(_ENV.myHero.charName, b_a[2], b_a[3], b_a[4], b_a[5], b_a[6], b_a[7], b_a[8], b_a[9], b_a[10], b_a[11], b_a[12], b_a[13], b_a[14], b_a[15])
            end
          end
        end
        if rebornskillslist then
          return
        end
      end
      function _ENV._Data:IsMinion(a_a)
        return self:GetUnitData()[a_a.charName]
      end
      function _ENV._Data:AddChannelledSpell(a_a, b_a, c_a)
        if a_a == myHero.charName then
          table.insert(self.ChannelledSpells, {Key = b_a, Buff = c_a})
        end
      end
      function _ENV._Data:AddResetSpell(a_a)
        self.ResetSpells[a_a] = true
      end
      function _ENV._Data:AddSpellAttack(a_a)
        self.SpellAttacks[a_a] = true
      end
      function _ENV._Data:AddNoneAttack(a_a)
        self.NoneAttacks[a_a] = true
      end
      function _ENV._Data:AddChampionData(a_a, b_a, c_a, d_a, _aa)
        self.ChampionData[a_a] = {
          Name = a_a,
          ProjectileSpeed = b_a,
          GameplayCollisionRadius = c_a,
          BugDelay = d_a and d_a or 0,
          Priority = _aa
        }
      end
      function _ENV._Data:GetChampionRole(a_a)
        return self.ChampionData[a_a] and self.ChampionData[a_a].Priority or nil
      end
      function _ENV._Data:AddMinionData(a_a, b_a, c_a)
        self.MinionData[a_a] = {Delay = b_a, ProjectileSpeed = c_a}
      end
      function _ENV._Data:AddJungleMonster(a_a, b_a)
        self.JungleData[a_a] = b_a
      end
      function _ENV._Data:GetJunglePriority(a_a)
        return self.JungleData[a_a]
      end
      function _ENV._Data:AddItemData(a_a, b_a, c_a, d_a, _aa)
        self.ItemData[c_a] = _Item(a_a, b_a, c_a, d_a, _aa)
      end
      function _ENV._Data:AddWardData(a_a, b_a, c_a, d_a, _aa, aaa)
        table.insert(self.WardData, {
          CharName = a_a,
          Name = b_a,
          SpellName = c_a,
          Type = d_a,
          Range = _aa,
          Duration = aaa
        })
      end
      function _ENV._Data:AddSkillData(a_a, b_a, c_a, d_a, _aa, aaa, baa, caa, daa, _ba, aba, bba, cba, dba, _ca)
        if myHero.charName == a_a then
          local aca = _Skill(b_a, c_a, d_a, _aa, aaa, baa, caa, daa, _ba, aba, bba, cba, dba, nil, _ca)
          table.insert(self.Skills, aca)
        end
      end
      function _ENV._Data:GetProjectileSpeed(a_a)
        if projectilespeeds[a_a] then
          return projectilespeeds[a_a] / 1000
        else
          return self.ChampionData[a_a] and self.ChampionData[a_a].ProjectileSpeed or nil
        end
      end
      function _ENV._Data:GetGameplayCollisionRadius(a_a)
        return self.ChampionData[a_a] and self.ChampionData[a_a].GameplayCollisionRadius or 65
      end
      function _ENV._Data:IsResetSpell(a_a)
        return self.ResetSpells[a_a.name]
      end
      function _ENV._Data:IsAttack(a_a)
        return (self.SpellAttacks[a_a.name] or Helper:StringContains(a_a.name, "attack")) and not self.NoneAttacks[a_a.name]
      end
      function _ENV._Data:IsJungleMinion(a_a)
        return a_a and a_a.name and self.JungleData[a_a.name] ~= nil
      end
      function _ENV._Data:IsCannonMinion(a_a)
        return a_a and a_a.charName and a_a.charName:find("Cannon") or false
      end
      function _ENV._Data:IsWard(a_a)
        for b_a, c_a in pairs(self.WardData) do
          if c_a.Name == a_a.name then
            return true
          end
        end
        return false
      end
      function _ENV._Data:IsWardSpell(a_a)
        for b_a, c_a in pairs(self.WardData) do
          if c_a.SpellName:lower() == a_a.name:lower() then
            return true
          end
        end
        return false
      end
      function _ENV._Data:GenerateHitBoxData()
        for i = 1, heroManager.iCount do
          local a_a = heroManager:GetHero(i)
          self.EnemyHitBoxes[a_a.charName] = Helper:GetDistance(a_a.minBBox, a_a.maxBBox)
        end
        GetSave("SidasAutoCarry").EnemyHitBoxes = {
          TimeSaved = GetGameTimer(),
          Data = self.EnemyHitBoxes
        }
      end
      function _ENV._Data:LoadHitBoxData()
        local a_a = GetSave("SidasAutoCarry").EnemyHitBoxes
        if a_a then
          self.EnemyHitBoxes = a_a.Data
        else
          self:GenerateHitBoxData()
        end
      end
      function _ENV._Data:GetHitBoxLastSavedTime()
        local a_a = GetSave("SidasAutoCarry").EnemyHitBoxes
        if a_a then
          a_a = a_a.TimeSaved
        else
          a_a = math.huge
        end
        return a_a
      end
      function _ENV._Data:GetOriginalHitBox(a_a)
        return self.EnemyHitBoxes[a_a.charName]
      end
      function _ENV._Data:EnemyIsImmune(a_a)
        if self.ImmuneEnemies[a_a.charName] then
          if a_a.charName == "Tryndamere" and a_a.health < MyHero:GetTotalAttackDamageAgainstTarget(a_a) then
            return true
          elseif a_a.charName ~= "Tryndamere" then
            return true
          end
        end
      end
      function _ENV._Data:GetChampionType(a_a)
        local b_a = self.ChampionData[Cham.charName].Priority
        if b_a == 1 then
          return "ADC"
        elseif b_a == 2 then
          return "AP"
        elseif b_a == 3 then
          return "Support"
        elseif b_a == 4 then
          return "Bruiser"
        elseif b_a == 5 then
          return "Tank"
        end
      end
      class("_Azir")
      _ENV.Azir = nil
      function _ENV._Azir:__init()
        self.soldiers = {}
        self.soldier_range = 370
        self.last_soldier_spawned = 0
        AddProcessSpellCallback(function(a_a, b_a)
          self:_OnProcessSpell(a_a, b_a)
        end)
        AddCreateObjCallback(function(a_a)
          self:_OnCreateObj(a_a)
        end)
        AddDrawCallback(function()
          self:_OnDraw()
        end)
        AddAnimationCallback(function(a_a, b_a)
          self:_OnAnimation(a_a, b_a)
        end)
        Azir = self
        self.CanOrbwalkTargetBackup = Orbwalker.CanOrbwalkTarget
        function Orbwalker:CanOrbwalkTarget(a_a)
          if ValidTarget(a_a) then
            for b_a, c_a in pairs(Azir.soldiers) do
              if Helper:GetDistance(c_a) < 950 and Helper:GetDistance(c_a, a_a) < Azir.soldier_range then
                return true
              end
            end
            if a_a.type == myHero.type then
              if Helper:GetDistance(a_a) - Data:GetGameplayCollisionRadius(a_a.charName) - self:GetScalingRange(a_a) + 10 < MyHero.TrueRange then
                return true
              end
            elseif Helper:GetDistance(a_a) - Data:GetGameplayCollisionRadius(a_a.charName) + 10 < MyHero.TrueRange then
              return true
            end
          end
          return false
        end
        function _Orbwalker:CanShoot(a_a)
          if Azir.soldier_shooting or Helper:GetTime() - Azir.last_soldier_spawned < 1000 / (myHero.attackSpeed * self.BaseAttackSpeed) then
            return false
          else
            a_a = a_a or 0
            return Helper:GetTime() + a_a + GetLatency() / 2 - self.LastAttack >= 1000 / (myHero.attackSpeed * self.BaseAttackSpeed)
          end
        end
        AzirMenu = scriptConfig("Sida's Auto Carry: Azir", "sidasacazir")
        AzirMenu:addParam("drawCircles", "Draw Circles Around Soldiers", SCRIPT_PARAM_ONOFF, true)
      end
      function _ENV._Azir:_OnProcessSpell(a_a, b_a)
        if a_a.isMe and b_a.name == "azirbasicattacksoldier" then
          self.soldier_shooting = true
          DelayAction(function()
            Azir.soldier_shooting = false
          end, b_a.windUpTime)
        elseif a_a.isMe and b_a.name == myHero:GetSpellData(_W).name then
          self.next_soldier_mine = true
          self.last_soldier_spawned = Helper:GetTime()
        end
      end
      function _ENV._Azir:_OnCreateObj(a_a)
        if a_a and a_a.name == "AzirSoldier" and self.next_soldier_mine then
          table.insert(self.soldiers, a_a)
          self.next_soldier_mine = false
        end
      end
      function _ENV._Azir:_OnDraw()
        if not AzirMenu.drawCircles then
          return
        end
        for a_a, b_a in pairs(self.soldiers) do
          if Helper:GetDistance(b_a) < 950 then
            Helper:DrawCircleObject(b_a, self.soldier_range, ARGB(255, 0, 255, 0), 1)
          else
            Helper:DrawCircleObject(b_a, self.soldier_range, ARGB(255, 255, 0, 0), 4)
          end
        end
      end
      function _ENV._Azir:_OnAnimation(a_a, b_a)
        for c_a, d_a in pairs(self.soldiers) do
          if a_a == d_a and b_a == "Death" then
            table.remove(self.soldiers, c_a)
          end
        end
      end
      class("_Jayce")
      function _ENV._Jayce:__init()
        Data:bind("OnGainBuff", function(a_a, b_a)
          self:_OnGainBuff(a_a, b_a)
        end)
      end
      function _ENV._Jayce:_OnGainBuff(a_a, b_a)
        if a_a.isMe and (b_a.name == "jaycestancegun" or b_a.name == "jaycestancehammer") then
          Orbwalker:ResetOrbwalkValues()
        end
      end
      class("_Swain")
      function _ENV._Swain:__init()
        Data:bind("OnGainBuff", function(a_a, b_a)
          self:_OnGainBuff(a_a, b_a)
        end)
        Data:bind("OnLoseBuff", function(a_a, b_a)
          self:_OnLoseBuff(a_a, b_a)
        end)
      end
      function _ENV._Swain:_OnGainBuff(a_a, b_a)
        if a_a.isMe and b_a.name == "SwainMetamorphism" then
          Orbwalker:ResetOrbwalkValues()
        end
      end
      function _ENV._Swain:_OnLoseBuff(a_a, b_a)
        if a_a.isMe and b_a.name == "SwainMetamorphism" then
          Orbwalker:ResetOrbwalkValues()
        end
      end
      class("_Gnar")
      function _ENV._Gnar:__init()
        Data:bind("OnGainBuff", function(a_a, b_a)
          self:_OnGainBuff(a_a, b_a)
        end)
        Data:bind("OnLoseBuff", function(a_a, b_a)
          self:_OnLoseBuff(a_a, b_a)
        end)
      end
      function _ENV._Gnar:_OnGainBuff(a_a, b_a)
        if a_a.isMe and b_a.name == "gnartransform" then
          Orbwalker:ResetOrbwalkValues()
        end
      end
      function _ENV._Gnar:_OnLoseBuff(a_a, b_a)
        if a_a.isMe and b_a.name == "gnartransform" then
          Orbwalker:ResetOrbwalkValues()
        end
      end
      class("_Nidalee")
      function _ENV._Nidalee:__init()
        AddProcessSpellCallback(function(a_a, b_a)
          self:_OnProcessSpell(a_a, b_a)
        end)
      end
      function _ENV._Nidalee:_OnProcessSpell(a_a, b_a)
        if a_a.isMe and b_a.name == "AspectOfTheCougar" then
          Orbwalker:ResetOrbwalkValues()
        end
      end
      class("_Tristana")
      function _ENV._Tristana:__init()
        AddTickCallback(function()
          self:_OnTick()
        end)
      end
      function _ENV._Tristana:_OnTick()
        local a_a = Skills:GetSkill(_E)
        local b_a = Skills:GetSkill(_R)
        local c_a = MyHero.TrueRange
        if a_a then
          local d_a = Crosshair:GetTarget()
          if Orbwalker:CanOrbwalkTarget(d_a) then
            c_a = Helper:GetDistance(d_a)
          end
          a_a.Range = c_a
          b_a.Range = c_a
        end
      end
      class("_Vayne")
      function _ENV._Vayne:__init()
        self.bushWardPos = nil
        self.tp = TargetPredictionVIP(1000, 2200, 0.25)
        self.SpellData = {}
        self.SpellExpired = true
        AddTickCallback(function()
          self:_OnTick()
        end)
        AddProcessSpellCallback(function(a_a, b_a)
          self:_OnProcessSpell(a_a, b_a)
        end)
        VayneMenu = scriptConfig("Sida's Auto Carry: Vayne", "sidasacvayne")
        _G.RebornVayneMenu = VayneMenu
        VayneMenu:addSubMenu("Configuration", "sidasacvaynesub")
        VayneMenu:addSubMenu("Allowed Condemn Targets", "sidasacvayneallowed")
        VayneMenu:addParam("toggleMode", "Toggle Mode (Requires Reload)", SCRIPT_PARAM_ONOFF, false)
        if VayneMenu.toggleMode then
          VayneMenu:addParam("Enabled", "Auto-Condemn", SCRIPT_PARAM_ONKEYTOGGLE, true, GetKey("N"))
        else
          VayneMenu:addParam("Enabled", "Auto-Condemn", SCRIPT_PARAM_ONKEYDOWN, false, 32)
        end
        VayneMenu.sidasacvaynesub:addParam("condemnClosers", "Auto-Condemn Gap Closers", SCRIPT_PARAM_ONOFF, true)
        VayneMenu.sidasacvaynesub:addParam("pushDistance", "Max Condemn Distance", SCRIPT_PARAM_SLICE, 390, 0, 450, 0)
        VayneMenu.sidasacvaynesub:addParam("condemnSAC", "Only condemn Reborn target", SCRIPT_PARAM_ONOFF, true)
        VayneMenu.sidasacvaynesub:addParam("sep", "", SCRIPT_PARAM_INFO, "")
        VayneMenu.sidasacvaynesub:addParam("sep", "Condemn Adjustment:", SCRIPT_PARAM_INFO, "")
        VayneMenu.sidasacvaynesub:addParam("adjustment", "None", SCRIPT_PARAM_SLICE, 0, -200, 200, 0)
        for a_a, b_a in pairs(GetEnemyHeroes()) do
          VayneMenu.sidasacvayneallowed:addParam("enabled" .. b_a.charName, b_a.charName, SCRIPT_PARAM_ONOFF, true)
        end
      end
      function _ENV._Vayne:IsWall(a_a, b_a)
        for d_a, _aa in ipairs(Minions.EnemyMinions.objects) do
          if GetDistance(b_a, _aa) < 100 then
            return false
          end
        end
        local c_a = CalculatePath(a_a or myHero, b_a)
        return c_a and GetDistance(c_a.endPath, b_a) > 150 + VayneMenu.sidasacvaynesub.adjustment or false
      end
      function _ENV._Vayne:DoCondemn(a_a)
        local b_a, c_a, d_a = db:GetLineCastPosition(a_a, 0.35, 0, 600, 2200, _ENV.myHero, false)
        if c_a > 1 then
          local _aa = 30
          local aaa = _ENV.math.ceil(_ENV.VayneMenu.sidasacvaynesub.pushDistance / _aa)
          for i = 1, _aa do
            local baa = _ENV.Vector(b_a) + _ENV.Vector(_ENV.Vector(b_a) - _ENV.Vector(_ENV.myHero)):normalized() * (aaa * i)
            local caa = _ENV.D3DXVECTOR3(baa.x, baa.y, baa.z)
            if self:IsWall(a_a, caa) then
              local daa = _ENV.Vector(b_a) + _ENV.Vector(_ENV.Vector(b_a) - _ENV.Vector(_ENV.myHero)):normalized() * (aaa * i + 30)
              local _ba = _ENV.D3DXVECTOR3(daa.x, daa.y, daa.z)
              if self:IsWall(a_a, _ba) then
                _ENV.CastSpell(_ENV._E, a_a)
              end
            end
          end
        end
      end
      function _ENV._Vayne:_OnTick()
        local a_a = not Streaming.StreamEnabled and DrawingMenu.PermaShow
        VayneMenu.sidasacvaynesub._param[6].text = VayneMenu.sidasacvaynesub.adjustment < 0 and "More Frequent" or VayneMenu.sidasacvaynesub.adjustment > 0 and "More Accurate" or "Default"
        CustomPermaShow("Auto-Condemn", "      Active", VayneMenu.Enabled and a_a, 1426521024)
        if VayneMenu.Enabled and myHero:CanUseSpell(_E) == READY then
          if VayneMenu.sidasacvaynesub.condemnClosers then
            if not self.SpellExpired and Helper:GetTime() - self.SpellData.spellCastedTick <= self.SpellData.spellRange / self.SpellData.spellSpeed * 1000 then
              local b_a = self.SpellData.spellEndPos - self.SpellData.spellStartPos:normalized()
              local c_a = self.SpellData.spellStartPos + b_a
              local d_a = self.SpellData.spellStartPos + b_a * self.SpellData.spellRange
              local _aa = Point(myHero.x, myHero.z)
              local aaa = LineSegment(Point(c_a.x, c_a.y), Point(d_a.x, d_a.y))
              if aaa:distance(_aa) <= (not self.SpellData.spellIsAnExpetion and 65 or 200) then
                CastSpell(_E, self.SpellData.spellSource)
              end
            else
              self.SpellExpired = true
              self.SpellData = {}
            end
          end
          if VayneMenu.sidasacvaynesub.condemnSAC then
            local b_a = AutoCarry.Crosshair.Attack_Crosshair.target
            if ValidTarget(b_a, 725) then
              self:DoCondemn(b_a)
            end
          else
            for b_a, c_a in pairs(GetEnemyHeroes()) do
              if VayneMenu.sidasacvayneallowed["enabled" .. c_a.charName] and ValidTarget(c_a, 725) then
                self:DoCondemn(c_a)
              end
            end
          end
        end
      end
      function _ENV._Vayne:FindNearestBushSpot(a_a)
        local b_a = a_a
        local c_a = Helper:GetDistance(a_a)
        MyPos = Vector(myHero.x, myHero.y, myHero.z)
        for i = c_a, 0, -1 do
          endPos = Vector(a_a.x, a_a.y, a_a.z)
          checkPos = MyPos - MyPos - endPos:normalized() * i
          if IsWallOfGrass(D3DXVECTOR3(checkPos.x, checkPos.y, checkPos.z)) then
            b_a = MyPos - MyPos - endPos:normalized() * (i + 10)
          else
            break
          end
        end
        return b_a
      end
      function _ENV._Vayne:FindNearestNonWall(a_a, b_a, c_a, d_a, _aa)
        if not IsWall(D3DXVECTOR3(a_a, b_a, c_a)) then
          return nil
        end
        local aaa, baa = _aa or 1, 50
        a_a, b_a, c_a, d_a = math.round(a_a / baa) * baa, math.round(b_a / baa) * baa, math.round(c_a / baa) * baa, d_a and math.floor(d_a / baa) or math.huge
        local caa = function(daa, _ba)
          return a_a + daa * baa, b_a, c_a + _ba * baa
        end
        while aaa <= d_a do
          for i = 1, 4 do
            local bba = D3DXVECTOR3(caa(i == 2 and aaa or i == 4 and -aaa or 0, i == 1 and aaa or i == 3 and -aaa or 0))
            if not IsWall(bba) then
              return bba
            end
          end
          local daa, _ba, aba = 1 - aaa, 0, aaa
          while _ba < aba - 1 do
            _ba = _ba + 1
            if daa < 0 then
              daa = daa + 1 + _ba + _ba
            else
              aba, daa = aba - 1, daa + 1 + _ba + _ba - aba - aba
            end
            for i = 1, 8 do
              local bba = math.ceil(i / 2) % 2 == 0
              local cba = D3DXVECTOR3(caa(((i + 1) % 2 == 0 and 1 or -1) * (bba and _ba or aba), (i <= 4 and 1 or -1) * (bba and aba or _ba)))
              if not IsWall(cba) then
                return cba
              end
            end
          end
          aaa = aaa + 1
        end
      end
      function _ENV._Vayne:_OnProcessSpell(a_a, b_a)
        if not VayneMenu.sidasacvaynesub.condemnClosers then
          return
        end
        local c_a = {
          Aatrox = {
            true,
            spell = _Q,
            range = 1000,
            projSpeed = 1200
          },
          Akali = {
            true,
            spell = _R,
            range = 800,
            projSpeed = 2200
          },
          Alistar = {
            true,
            spell = _W,
            range = 650,
            projSpeed = 2000
          },
          Diana = {
            true,
            spell = _R,
            range = 825,
            projSpeed = 2000
          },
          Gragas = {
            true,
            spell = _E,
            range = 600,
            projSpeed = 2000
          },
          Graves = {
            true,
            spell = _E,
            range = 425,
            projSpeed = 2000,
            exeption = true
          },
          Hecarim = {
            true,
            spell = _R,
            range = 1000,
            projSpeed = 1200
          },
          Irelia = {
            true,
            spell = _Q,
            range = 650,
            projSpeed = 2200
          },
          JarvanIV = {
            true,
            spell = jarvanAddition,
            range = 770,
            projSpeed = 2000
          },
          Jax = {
            true,
            spell = _Q,
            range = 700,
            projSpeed = 2000
          },
          Jayce = {
            true,
            spell = "JayceToTheSkies",
            range = 600,
            projSpeed = 2000
          },
          Khazix = {
            true,
            spell = _E,
            range = 900,
            projSpeed = 2000
          },
          Leblanc = {
            true,
            spell = _W,
            range = 600,
            projSpeed = 2000
          },
          LeeSin = {
            true,
            spell = "blindmonkqtwo",
            range = 1300,
            projSpeed = 1800
          },
          Leona = {
            true,
            spell = _E,
            range = 900,
            projSpeed = 2000
          },
          Malphite = {
            true,
            spell = _R,
            range = 1000,
            projSpeed = 1500 + a_a.ms
          },
          Maokai = {
            true,
            spell = _Q,
            range = 600,
            projSpeed = 1200
          },
          MonkeyKing = {
            true,
            spell = _E,
            range = 650,
            projSpeed = 2200
          },
          Pantheon = {
            true,
            spell = _W,
            range = 600,
            projSpeed = 2000
          },
          Poppy = {
            true,
            spell = _E,
            range = 525,
            projSpeed = 2000
          },
          Renekton = {
            true,
            spell = _E,
            range = 450,
            projSpeed = 2000
          },
          Sejuani = {
            true,
            spell = _Q,
            range = 650,
            projSpeed = 2000
          },
          Shen = {
            true,
            spell = _E,
            range = 575,
            projSpeed = 2000
          },
          Tristana = {
            true,
            spell = _W,
            range = 900,
            projSpeed = 2000
          },
          Tryndamere = {
            true,
            spell = "Slash",
            range = 650,
            projSpeed = 1450
          },
          XinZhao = {
            true,
            spell = _E,
            range = 650,
            projSpeed = 2000
          }
        }
        if a_a.type == myHero.type and a_a.team ~= myHero.team and c_a[a_a.charName] and 2000 > Helper:GetDistance(a_a) and b_a ~= nil then
          if b_a.name == (type(c_a[a_a.charName].spell) == "number" and a_a:GetSpellData(c_a[a_a.charName].spell).name or c_a[a_a.charName].spell) then
            if b_a.target and b_a.target.name == myHero.name or c_a[a_a.charName].spell == "blindmonkqtwo" then
              CastSpell(_E, a_a)
            else
              self.SpellExpired = false
              self.SpellData = {
                spellSource = a_a,
                spellCastedTick = Helper:GetTime(),
                spellStartPos = Point(b_a.startPos.x, b_a.startPos.z),
                spellEndPos = Point(b_a.endPos.x, b_a.endPos.z),
                spellRange = c_a[a_a.charName].range,
                spellSpeed = c_a[a_a.charName].projSpeed,
                spellIsAnExpetion = c_a[a_a.charName].exeption or false
              }
            end
          end
        end
      end
      function _ENV.areClockwise(a_a, b_a)
        return -a_a.x * b_a.y + a_a.y * b_a.x > 0
      end
      function _ENV.sign(a_a)
        if a_a > 0 then
          return 1
        elseif a_a < 0 then
          return -1
        end
      end
      function _ENV.GetCone(a_a, b_a)
        n = 1
        v3 = 0
        v2 = 0
        v1 = 0
        largeV2 = 0
        largeV1 = 0
        largeN = 0
        smallBisect = 0
        theta2 = 0
        theta1 = 0
        coneTargetsTable = {}
        for i = 1, heroManager.iCount do
          hero = heroManager:getHero(i)
          if ValidTarget(hero, a_a) then
            coneTargetsTable[n] = hero
            n = n + 1
          end
        end
        if #coneTargetsTable >= 2 then
          for i = 1, #coneTargetsTable do
            for j = 1, #coneTargetsTable do
              if i ~= j then
                v1 = Vector(coneTargetsTable[i].x - player.x, coneTargetsTable[i].z - player.z)
                v2 = Vector(coneTargetsTable[j].x - player.x, coneTargetsTable[j].z - player.z)
                thetav1 = sign(v1.y) * 90 - math.deg(math.atan(v1.x / v1.y))
                thetav2 = sign(v2.y) * 90 - math.deg(math.atan(v2.x / v2.y))
                thetaBetween = thetav2 - thetav1
                if b_a >= thetaBetween and 0 < thetaBetween then
                  if #coneTargetsTable == 2 then
                    largeV1 = v1
                    largeV2 = v2
                  else
                    tempN = 0
                    for k = 1, #coneTargetsTable do
                      if k ~= i and k ~= j then
                        v3 = Vector(coneTargetsTable[k].x - player.x, coneTargetsTable[k].z - player.z)
                        if areClockwise(v3, v1) and not areClockwise(v3, v2) then
                          tempN = tempN + 1
                        end
                      end
                    end
                    if tempN > largeN then
                      largeN = tempN
                      largeV1 = v1
                      largeV2 = v2
                    end
                  end
                end
              end
            end
          end
        elseif #coneTargetsTable == 1 then
          return coneTargetsTable[1]
        end
        if largeV1 == 0 or largeV2 == 0 then
          return nil
        else
          if largeV1.y == 0 then
            theta1 = 0
          else
            theta1 = sign(largeV1.y) * 90 - math.deg(math.atan(largeV1.x / largeV1.y))
          end
          if largeV2.y == 0 then
            theta2 = 0
          else
            theta2 = sign(largeV2.y) * 90 - math.deg(math.atan(largeV2.x / largeV2.y))
          end
          smallBisect = math.rad((theta1 + theta2) / 2)
          vResult = {}
          vResult.x = a_a * math.cos(smallBisect) + player.x
          vResult.y = player.y
          vResult.z = a_a * math.sin(smallBisect) + player.z
          return vResult
        end
      end

      function AutoCarry.GetAttackTarget(a_a)
        return Crosshair:GetTarget()
      end
      function AutoCarry.GetKillableMinion()
        return Minions.KillableMinion
      end
      function AutoCarry.GetMinionTarget()
        return nil
      end
      function AutoCarry.EnemyMinions()
        return Minions.EnemyMinions
      end
      function AutoCarry.AllyMinions()
        return Minions.AllyMinions
      end
      function AutoCarry.GetJungleMobs()
        return Jungle.JungleMonsters
      end
      function AutoCarry.GetLastAttacked()
        return Orbwalker.LastEnemyAttacked
      end
      function AutoCarry.GetNextAttackTime()
        return Orbwalker:GetNextAttackTime()
      end
      function AutoCarry.CastSkillshot(a_a, b_a)
        if VIP_USER then
          pred = TargetPredictionVIP(a_a.range, a_a.speed * 1000, a_a.delay / 1000 - GetLatency() / 2 / 1000, a_a.width)
        elseif not VIP_USER then
          pred = TargetPrediction(a_a.range, a_a.speed, a_a.delay, a_a.width)
        end
        local c_a = pred:GetPrediction(b_a)
        if c_a and Helper:GetDistance(c_a) <= a_a.range then
          if VIP_USER then
            if not a_a.minions or not AutoCarry.GetCollision(a_a, myHero, c_a) then
              CastSpell(a_a.spellKey, c_a.x, c_a.z)
            end
          elseif not VIP_USER and (not a_a.minions or not AutoCarry.GetCollision(a_a, myHero, c_a)) then
            CastSpell(a_a.spellKey, c_a.x, c_a.z)
          end
        end
      end
      function AutoCarry.GetCollision(a_a, b_a, c_a)
        if VIP_USER then
          local d_a = Collision(a_a.range, a_a.speed * 1000, a_a.delay / 1000 - GetLatency() / 2 / 1000, a_a.width)
          return d_a:GetMinionCollision(b_a, c_a)
        else
          return willHitMinion(c_a, a_a.width)
        end
      end
      function AutoCarry.GetPrediction(a_a, b_a)
        if VIP_USER then
          pred = TargetPredictionVIP(a_a.range, a_a.speed * 1000, a_a.delay / 1000, a_a.width)
        elseif not VIP_USER then
          pred = TargetPrediction(a_a.range, a_a.speed, a_a.delay, a_a.width)
        end
        return pred:GetPrediction(b_a)
      end
      function AutoCarry.IsValidHitChance(a_a, b_a)
        return true
      end
      function AutoCarry.GetProdiction(a_a, b_a, c_a, d_a, _aa, aaa, baa)
        return AutoCarry.Plugins:GetProdiction(a_a, b_a, c_a, d_a, _aa, aaa, baa)
      end
      function _ENV.willHitMinion(a_a, b_a)
        for c_a, d_a in pairs(Minions.EnemyMinions.objects) do
          if d_a ~= nil and d_a.valid and string.find(d_a.name, "Minion_") == 1 and d_a.team ~= player.team and d_a.dead == false and a_a ~= nil then
            ex = player.x
            ez = player.z
            tx = a_a.x
            tz = a_a.z
            dx = ex - tx
            dz = ez - tz
            if dx ~= 0 then
              m = dz / dx
              c = ez - m * ex
            end
            mx = d_a.x
            mz = d_a.z
            distanc = math.abs(mz - m * mx - c) / math.sqrt(m * m + 1)
            if b_a > distanc and math.sqrt((tx - ex) * (tx - ex) + (tz - ez) * (tz - ez)) > math.sqrt((tx - mx) * (tx - mx) + (tz - mz) * (tz - mz)) then
              return true
            end
          end
        end
        return false
      end
      if FileExist(LIB_PATH .. "SidasAutoCarryPlugin - " .. myHero.charName .. ".lua") then
        _ENV._LegacyPlugin()
      end
      _ENV.AddTickCallback(function()
        if Keys and Keys.LastHit then
          if LastHitMenu.AntiFarm then
            if Orbwalker.EnemyLastHitting and Orbwalker.EnemyLastHitting.EndsAt < Helper:GetTime() then
              Orbwalker.EnemyLastHitting = nil
            end
            if Orbwalker.EnemyLastHitting and Orbwalker:CanOrbwalkTarget(Orbwalker.EnemyLastHitting.unit) then
              Orbwalker:Orbwalk(Orbwalker.EnemyLastHitting.unit)
            elseif Orbwalker.EnemyLastHitting and Orbwalker:CanOrbwalkTargetCustomRange(Orbwalker.EnemyLastHitting.unit, myHero.range + 150) then
              MyHero:Move(Orbwalker.EnemyLastHitting.unit)
            else
              Minions:LastHit()
              Orbwalker.EnemyLastHitting = nil
            end
          else
            Minions:LastHit()
          end
        end
        if Keys and Keys.AutoCarry then
          if Crosshair.TargetLock then
            Skills:CastAll(Crosshair.TargetLock)
            Items:UseAll(Crosshair.TargetLock)
            Orbwalker:Orbwalk(Crosshair.TargetLock)
          else
            local a_a = Crosshair:GetTarget()
            if ValidTarget(a_a) and a_a.type == myHero.type then
              Items:UseAll(Crosshair.Attack_Crosshair.target)
              Skills:CastAll(a_a)
              Orbwalker:Orbwalk(Crosshair.Attack_Crosshair.target)
            elseif Structures:CanOrbwalkStructure() and ConfigurationMenu.AttackStructures then
              Orbwalker:OrbwalkIgnoreChecks(Structures:GetTargetStructure())
            else
              Orbwalker:Orbwalk(Jungle:GetFocusedMonster())
            end
          end
        end
        if Keys and Keys.LaneClear then
          if Crosshair.TargetLock and LaneClearMenu.AttackEnemies then
            Skills:CastAll(Crosshair.TargetLock)
            Items:UseAll(Crosshair.TargetLock)
            Orbwalker:Orbwalk(Crosshair.TargetLock)
          else
            local a_a = Crosshair:GetTarget()
            if ValidTarget(a_a) then
              if a_a.type == myHero.type and LaneClearMenu.AttackEnemies then
                Items:UseAll(Crosshair.Attack_Crosshair.target)
                Skills:CastAll(a_a)
              elseif SkillsMenu and SkillsMenu.SkillFarm and Data:IsJungleMinion(a_a) then
                for b_a, c_a in pairs(Skills.SkillsList) do
                  if SkillsMenu[c_a.RawName].Jungle then
                    c_a:Cast(a_a)
                  end
                end
              end
            end
            Minions:LaneClear()
          end
        end
        if Keys and Keys.MixedMode then
          if Crosshair.TargetLock then
            Skills:CastAll(Crosshair.TargetLock)
            Items:UseAll(Crosshair.TargetLock)
            Orbwalker:Orbwalk(Crosshair.TargetLock)
          else
            local a_a = Crosshair:GetTarget()
            if ValidTarget(a_a) and a_a.type == myHero.type then
              Items:UseAll(Crosshair.Attack_Crosshair.target)
              Skills:CastAll(a_a)
            end
            Minions:MixedMode()
          end
        end
        if Keys and not Keys.AutoCarry and not Keys.MixedMode and not Keys.LaneClear and not Keys.LastHit and MinionHealthMenu.MinionMarker then
          Minions:MarkerOnly()
        end
      end)


    MINION_ALL = "All"
    MINION_ENEMY = "Enemy"
    MINION_ALLY = "Ally"
    MINION_JUNGLE = "Jungle"
    MINION_OTHER = "Other"
    function MINION_SORT_HEALTH_ASC(_c, ac)
      return _c.health < ac.health
    end
    function MINION_SORT_HEALTH_DEC(_c, ac)
      return _c.health > ac.health
    end
    function MINION_SORT_MAXHEALTH_ASC(_c, ac)
      return _c.maxHealth < ac.maxHealth
    end
    function MINION_SORT_MAXHEALTH_DEC(_c, ac)
      return _c.maxHealth > ac.maxHealth
    end
    function MINION_SORT_AD_ASC(_c, ac)
      return _c.ad < ac.ad
    end
    function MINION_SORT_AD_DEC(_c, ac)
      return _c.ad > ac.ad
    end
    class("_MinManager")
    function _MinManager:__init(_c, ac, bc, cc)
      self.mode = _c
      self.range = ac
      self.fromPos = bc or player
      self.sortMode = type(cc) == "function" and cc
      self.objects = {}
      self.iCount = 0
      self.minionTable = {
        All = {},
        Ally = {},
        Enemy = {},
        Jungle = {},
        Other = {}
      }
      local dc = GetGame().map.index
      if dc ~= 4 then
        self.allyName = "Minion_T" .. player.team
        self.enemyName = "Minion_T" .. TEAM_ENEMY
      else
        self.allyName = player.team == TEAM_BLUE and "Blue" or "Red"
        self.enemyName = player.team == TEAM_BLUE and "Red" or "Blue"
      end
      AddCreateObjCallback(function(_d)
        self:_OnCreateObj(_d)
      end)
      for i = 1, objManager.maxObjects do
        self:_OnCreateObj(objManager:getObject(i))
      end
      self:update()
    end
    function _MinManager:_OnCreateObj(_c)
      if _c and _c.valid and _c.type == "obj_AI_Minion" and not _c.dead then
        table.insert(self.minionTable.All, _c)
        if _c.name:sub(1, #self.allyName) == self.allyName then
          table.insert(self.minionTable.Ally, _c)
        elseif _c.name:sub(1, #self.enemyName) == self.enemyName then
          table.insert(self.minionTable.Enemy, _c)
        elseif _c.team == TEAM_NEUTRAL then
          table.insert(self.minionTable.Jungle, _c)
        else
          table.insert(self.minionTable.Other, _c)
        end
      end
    end
    function _MinManager:update()
      self.objects = {}
      for _c, ac in pairs(self.minionTable[self.mode]) do
        if ac and not ac.dead and GetDistance(self.fromPos, ac) <= self.range then
          table.insert(self.objects, ac)
        end
      end
      if self.sortMode then
        table.sort(self.objects, self.sortMode)
      end
      self.iCount = #self.objects
    end

 AutoCarry.Skills = _Skills()
      AutoCarry.Keys = _ENV._Keys()
      AutoCarry.Items = _Items()
      AutoCarry.Helper = _Helper()
      AutoCarry.Data = _ENV._Data()
      AutoCarry.Jungle = _Jungle()
      AutoCarry.MyHero = _MyHero()
      _DamagePred()
      AutoCarry.Minions = _Minions()
      AutoCarry.Crosshair = _Crosshair(_ENV.DAMAGE_PHYSICAL, MyHero.TrueRange, 0, false, false)
      AutoCarry.Orbwalker = _Orbwalker()
      AutoCarry.Plugins = _ENV._Plugins()
      Orbwalker = AutoCarry.Orbwalker
      Crosshair = AutoCarry.Crosshair
      Minions = AutoCarry.Minions
      MyHero = AutoCarry.MyHero
      Helper = AutoCarry.Helper
      Jungle = AutoCarry.Jungle
      _ENV.Data = AutoCarry.Data
      Items = AutoCarry.Items
      _ENV.Keys = AutoCarry.Keys
      Skills = AutoCarry.Skills
      _ENV._MenuManager()
      _ENV._Drawing()
      AutoCarry.Structures = _Structures()
      _ENV._MinionDraw()
      local dd, __a = _ENV.ScanDirectory(_ENV.BOL_PATH .. "Scripts\\SidasAutoCarryPlugins")
      for a_a, b_a in _ENV.pairs(__a) do
        _ENV.dofile(_ENV.BOL_PATH .. "Scripts\\SidasAutoCarryPlugins\\" .. AutoCarry.Helper:TrimString(b_a))
      end
      if myHero.charName == "Vayne" then
        _ENV._Vayne()
      elseif myHero.charName == "Tristana" then
        _ENV._Tristana()
      elseif myHero.charName == "Nidalee" then
        _ENV._Nidalee()
      elseif myHero.charName == "Gnar" then
        _ENV._Gnar()
      elseif myHero.charName == "Swain" then
        _ENV._Swain()
      elseif myHero.charName == "Jayce" then
        _ENV._Jayce()
      elseif myHero.charName == "Azir" then
        AutoCarry.Azir = _ENV._Azir()
      end
      AutoCarry.SkillsCrosshair = AutoCarry.Crosshair.Skills_Crosshair
      AutoCarry.CanMove = true
      AutoCarry.CanAttack = true
      AutoCarry.MainMenu = {}
      AutoCarry.PluginMenu = nil
      AutoCarry.EnemyTable = _ENV.GetEnemyHeroes()
      AutoCarry.shotFired = false
      AutoCarry.OverrideCustomChampionSupport = false
      AutoCarry.CurrentlyShooting = false
      _ENV.DoneInit = true
      _G.RebornInitialised = true
      _G.Reborn_Initialised = true
      class("_LegacyPlugin")
      function _ENV._LegacyPlugin:__init()
        AutoCarry.PluginMenu = scriptConfig("Sida's Auto Carry Plugin: " .. myHero.charName, "sidasacplugin" .. myHero.charName)
        require("SidasAutoCarryPlugin - " .. myHero.charName)
        PrintSystemMessage("Loaded " .. myHero.charName .. " plugin!")
        AddTickCallback(function()
          self:_OnTick()
        end)
        if PluginOnTick then
          AddTickCallback(function()
            PluginOnTick()
          end)
        end
        if PluginOnDraw then
          AddDrawCallback(function()
            PluginOnDraw()
          end)
        end
        if PluginOnCreateObj then
          AddCreateObjCallback(function(a_a)
            PluginOnCreateObj(a_a)
          end)
        end
        if PluginOnDeleteObj then
          AddDeleteObjCallback(function(a_a)
            PluginOnDeleteObj(a_a)
          end)
        end
        if PluginOnLoad then
          PluginOnLoad()
        end
        if PluginOnUnload then
          AddUnloadCallback(function()
            PluginOnUnload()
          end)
        end
        if PluginOnWndMsg then
          AddMsgCallback(function(a_a, b_a)
            PluginOnWndMsg(a_a, b_a)
          end)
        end
        if PluginOnProcessSpell then
          AddProcessSpellCallback(function(a_a, b_a)
            PluginOnProcessSpell(a_a, b_a)
          end)
        end
        if PluginOnSendChat then
          AddChatCallback(function(a_a)
            PluginOnSendChat(a_a)
          end)
        end
        if PluginOnBugsplat then
          AddBugsplatCallback(function()
            PluginOnBugsplat()
          end)
        end
        if PluginOnAnimation then
          AddAnimationCallback(function(a_a, b_a)
            PluginOnAnimation(a_a, b_a)
          end)
        end
        if PluginOnSendPacket then
          AddSendPacketCallback(function(a_a)
            PluginOnSendPacket(a_a)
          end)
        end
        if PluginOnRecvPacket then
          AddRecvPacketCallback(function(a_a)
            PluginOnRecvPacket(a_a)
          end)
        end
        if PluginOnApplyParticle then
          AddParticleCallback(function(a_a, b_a)
            PluginOnApplyParticle(a_a, b_a)
          end)
        end
        if OnAttacked then
          RegisterOnAttacked(OnAttacked)
        end
        if PluginBonusLastHitDamage then
          Plugins:RegisterBonusLastHitDamage(PluginBonusLastHitDamage)
        end
        if CustomAttackEnemy then
          Plugins:RegisterPreAttack(CustomAttackEnemy)
        end
		end
		  function _ENV._LegacyPlugin:_OnTick()
        AutoCarry.MainMenu.AutoCarry = AutoCarryMenu.Active
        AutoCarry.MainMenu.LastHit = LastHitMenu.Active
        AutoCarry.MainMenu.MixedMode = MixedModeMenu.Active
        AutoCarry.MainMenu.LaneClear = LaneClearMenu.Active
        MyHero:MovementEnabled(AutoCarry.CanMove)
        MyHero:AttacksEnabled(AutoCarry.CanAttack)
        if #AutoCarry.EnemyTable < #Helper.EnemyTable then
          AutoCarry.EnemyTable = Helper.EnemyTable
        end
      end
